// Generated by dts-bundle-generator v5.9.0

declare class State<
  TContext,
  TEvent extends EventObject = EventObject,
  TStateSchema extends StateSchema<TContext> = any,
  TTypestate extends Typestate<TContext> = {
    value: any;
    context: TContext;
  },
> {
  value: StateValue;
  context: TContext;
  historyValue?: HistoryValue | undefined;
  history?: State<TContext, TEvent, TStateSchema, TTypestate>;
  actions: Array<ActionObject<TContext, TEvent>>;
  activities: ActivityMap;
  meta: any;
  events: TEvent[];
  event: TEvent;
  _event: SCXML.Event<TEvent>;
  _sessionid: string | null;
  /**
   * Indicates whether the state has changed from the previous state. A state is considered "changed" if:
   *
   * - Its value is not equal to its previous value, or:
   * - It has any new actions (side-effects) to execute.
   *
   * An initial state (with no history) will return `undefined`.
   */
  changed: boolean | undefined;
  /**
   * Indicates whether the state is a final state.
   */
  done: boolean | undefined;
  /**
   * The enabled state nodes representative of the state value.
   */
  configuration: Array<StateNode<TContext, any, TEvent, any>>;
  /**
   * The next events that will cause a transition from the current state.
   */
  nextEvents: EventType[];
  /**
   * The transition definitions that resulted in this state.
   */
  transitions: Array<TransitionDefinition<TContext, TEvent>>;
  /**
   * An object mapping actor IDs to spawned actors/invoked services.
   */
  children: Record<string, ActorRef<any>>;
  tags: Set<string>;
  /**
   * Creates a new State instance for the given `stateValue` and `context`.
   * @param stateValue
   * @param context
   */
  static from<TC, TE extends EventObject = EventObject>(
    stateValue: State<TC, TE, any, any> | StateValue,
    context?: TC | undefined,
  ): State<TC, TE, any, any>;
  /**
   * Creates a new State instance for the given `config`.
   * @param config The state config
   */
  static create<TC, TE extends EventObject = EventObject>(
    config: StateConfig<TC, TE>,
  ): State<TC, TE>;
  /**
   * Creates a new `State` instance for the given `stateValue` and `context` with no actions (side-effects).
   * @param stateValue
   * @param context
   */
  static inert<TC, TE extends EventObject = EventObject>(
    stateValue: State<TC, TE> | StateValue,
    context: TC,
  ): State<TC, TE>;
  /**
   * Creates a new State instance.
   * @param value The state value
   * @param context The extended state
   * @param historyValue The tree representing historical values of the state nodes
   * @param history The previous state
   * @param actions An array of action objects to execute as side-effects
   * @param activities A mapping of activities and whether they are started (`true`) or stopped (`false`).
   * @param meta
   * @param events Internal event queue. Should be empty with run-to-completion semantics.
   * @param configuration
   */
  constructor(config: StateConfig<TContext, TEvent>);
  /**
   * Returns an array of all the string leaf state node paths.
   * @param stateValue
   * @param delimiter The character(s) that separate each subpath in the string state node path.
   */
  toStrings(stateValue?: StateValue, delimiter?: string): string[];
  toJSON(): Pick<
    this,
    Exclude<keyof this, 'configuration' | 'transitions' | 'tags'>
  > & {
    tags: string[];
  };
  /**
   * Whether the current state value is a subset of the given parent state value.
   * @param parentStateValue
   */
  matches<TSV extends TTypestate['value']>(
    parentStateValue: TSV,
  ): this is State<
    (TTypestate extends any
      ? {
          value: TSV;
          context: any;
        } extends TTypestate
        ? TTypestate
        : never
      : never)['context'],
    TEvent,
    TStateSchema,
    TTypestate
  > & {
    value: TSV;
  };
  /**
   * Whether the current state configuration has a state node with the specified `tag`.
   * @param tag
   */
  hasTag(tag: string): boolean;
}
declare class StateNode<
  TContext = any,
  TStateSchema extends StateSchema = any,
  TEvent extends EventObject = EventObject,
  TTypestate extends Typestate<TContext> = {
    value: any;
    context: TContext;
  },
> {
  /**
   * The raw config used to create the machine.
   */
  config: StateNodeConfig<TContext, TStateSchema, TEvent>;
  /**
   * The initial extended state
   */
  context: Readonly<TContext>;
  /**
   * The relative key of the state node, which represents its location in the overall state value.
   */
  key: string;
  /**
   * The unique ID of the state node.
   */
  id: string;
  /**
   * The machine's own version.
   */
  version?: string;
  /**
   * The type of this state node:
   *
   *  - `'atomic'` - no child state nodes
   *  - `'compound'` - nested child state nodes (XOR)
   *  - `'parallel'` - orthogonal nested child state nodes (AND)
   *  - `'history'` - history state node
   *  - `'final'` - final state node
   */
  type: 'atomic' | 'compound' | 'parallel' | 'final' | 'history';
  /**
   * The string path from the root machine node to this node.
   */
  path: string[];
  /**
   * The initial state node key.
   */
  initial?: keyof TStateSchema['states'];
  /**
   * (DEPRECATED) Whether the state node is a parallel state node.
   *
   * Use `type: 'parallel'` instead.
   */
  parallel?: boolean;
  /**
   * Whether the state node is "transient". A state node is considered transient if it has
   * an immediate transition from a "null event" (empty string), taken upon entering the state node.
   */
  private _transient;
  /**
   * The child state nodes.
   */
  states: StateNodesConfig<TContext, TStateSchema, TEvent>;
  /**
   * The type of history on this state node. Can be:
   *
   *  - `'shallow'` - recalls only top-level historical state value
   *  - `'deep'` - recalls historical state value at all levels
   */
  history: false | 'shallow' | 'deep';
  /**
   * The action(s) to be executed upon entering the state node.
   */
  onEntry: Array<ActionObject<TContext, TEvent>>;
  /**
   * The action(s) to be executed upon exiting the state node.
   */
  onExit: Array<ActionObject<TContext, TEvent>>;
  /**
   * The activities to be started upon entering the state node,
   * and stopped upon exiting the state node.
   */
  activities: Array<ActivityDefinition<TContext, TEvent>>;
  strict: boolean;
  /**
   * The parent state node.
   */
  parent?: StateNode<TContext, any, TEvent, any>;
  /**
   * The root machine node.
   */
  machine: StateNode<TContext, any, TEvent, TTypestate>;
  /**
   * The meta data associated with this state node, which will be returned in State instances.
   */
  meta?: TStateSchema extends {
    meta: infer D;
  }
    ? D
    : any;
  /**
   * The data sent with the "done.state._id_" event if this is a final state node.
   */
  doneData?:
    | Mapper<TContext, TEvent, any>
    | PropertyMapper<TContext, TEvent, any>;
  /**
   * The string delimiter for serializing the path to a string. The default is "."
   */
  delimiter: string;
  /**
   * The order this state node appears. Corresponds to the implicit SCXML document order.
   */
  order: number;
  /**
   * The services invoked by this state node.
   */
  invoke: Array<InvokeDefinition<TContext, TEvent>>;
  options: MachineOptions<TContext, TEvent>;
  schema: MachineSchema<TContext, TEvent>;
  __xstatenode: true;
  private __cache;
  private idMap;
  tags: string[];
  constructor(
    /**
     * The raw config used to create the machine.
     */
    config: StateNodeConfig<TContext, TStateSchema, TEvent>,
    options?: Partial<MachineOptions<TContext, TEvent>>,
    /**
     * The initial extended state
     */
    context?: Readonly<TContext>,
  );
  private _init;
  /**
   * Clones this state machine with custom options and context.
   *
   * @param options Options (actions, guards, activities, services) to recursively merge with the existing options.
   * @param context Custom context (will override predefined context)
   */
  withConfig(
    options: Partial<MachineOptions<TContext, TEvent>>,
    context?: TContext | undefined,
  ): StateNode<TContext, TStateSchema, TEvent, TTypestate>;
  /**
   * Clones this state machine with custom context.
   *
   * @param context Custom context (will override predefined context, not recursive)
   */
  withContext(context: TContext): StateNode<TContext, TStateSchema, TEvent>;
  /**
   * The well-structured state node definition.
   */
  get definition(): StateNodeDefinition<TContext, TStateSchema, TEvent>;
  toJSON(): StateNodeDefinition<TContext, TStateSchema, TEvent>;
  /**
   * The mapping of events to transitions.
   */
  get on(): TransitionDefinitionMap<TContext, TEvent>;
  get after(): Array<DelayedTransitionDefinition<TContext, TEvent>>;
  /**
   * All the transitions that can be taken from this state node.
   */
  get transitions(): Array<TransitionDefinition<TContext, TEvent>>;
  private getCandidates;
  /**
   * All delayed transitions from the config.
   */
  private getDelayedTransitions;
  /**
   * Returns the state nodes represented by the current state value.
   *
   * @param state The state value or State instance
   */
  getStateNodes(
    state: StateValue | State<TContext, TEvent, any, TTypestate>,
  ): Array<StateNode<TContext, any, TEvent, TTypestate>>;
  /**
   * Returns `true` if this state node explicitly handles the given event.
   *
   * @param event The event in question
   */
  handles(event: Event<TEvent>): boolean;
  /**
   * Resolves the given `state` to a new `State` instance relative to this machine.
   *
   * This ensures that `.events` and `.nextEvents` represent the correct values.
   *
   * @param state The state to resolve
   */
  resolveState(
    state: State<TContext, TEvent, any, any>,
  ): State<TContext, TEvent, TStateSchema, TTypestate>;
  private transitionLeafNode;
  private transitionCompoundNode;
  private transitionParallelNode;
  private _transition;
  private next;
  private nodesFromChild;
  /**
   * Whether the given state node "escapes" this state node. If the `stateNode` is equal to or the parent of
   * this state node, it does not escape.
   */
  private escapes;
  private getActions;
  /**
   * Determines the next state given the current `state` and sent `event`.
   *
   * @param state The current State instance or state value
   * @param event The event that was sent at the current state
   * @param context The current context (extended state) of the current state
   */
  transition(
    state:
      | string
      | StateValueMap
      | State<TContext, TEvent, any, TTypestate>
      | undefined,
    event: Event<TEvent> | SCXML.Event<TEvent>,
    context?: TContext,
  ): State<TContext, TEvent, TStateSchema, TTypestate>;
  private resolveRaisedTransition;
  private resolveTransition;
  /**
   * Returns the child state node from its relative `stateKey`, or throws.
   */
  getStateNode(stateKey: string): StateNode<TContext, any, TEvent, TTypestate>;
  /**
   * Returns the state node with the given `stateId`, or throws.
   *
   * @param stateId The state ID. The prefix "#" is removed.
   */
  getStateNodeById(stateId: string): StateNode<TContext, any, TEvent, any>;
  /**
   * Returns the relative state node from the given `statePath`, or throws.
   *
   * @param statePath The string or string array relative path to the state node.
   */
  getStateNodeByPath(
    statePath: string | string[],
  ): StateNode<TContext, any, TEvent, any>;
  /**
   * Resolves a partial state value with its full representation in this machine.
   *
   * @param stateValue The partial state value to resolve.
   */
  resolve(stateValue: StateValue): StateValue;
  private getResolvedPath;
  private get initialStateValue();
  getInitialState(
    stateValue: StateValue,
    context?: TContext,
  ): State<TContext, TEvent, TStateSchema, TTypestate>;
  /**
   * The initial State instance, which includes all actions to be executed from
   * entering the initial state.
   */
  get initialState(): State<TContext, TEvent, TStateSchema, TTypestate>;
  /**
   * The target state value of the history state node, if it exists. This represents the
   * default state value to transition to if no history value exists yet.
   */
  get target(): StateValue | undefined;
  /**
   * Returns the leaf nodes from a state path relative to this state node.
   *
   * @param relativeStateId The relative state path to retrieve the state nodes
   * @param history The previous state to retrieve history
   * @param resolve Whether state nodes should resolve to initial child state nodes
   */
  getRelativeStateNodes(
    relativeStateId: StateNode<TContext, any, TEvent>,
    historyValue?: HistoryValue,
    resolve?: boolean,
  ): Array<StateNode<TContext, any, TEvent>>;
  get initialStateNodes(): Array<StateNode<TContext, any, TEvent, any>>;
  /**
   * Retrieves state nodes from a relative path to this state node.
   *
   * @param relativePath The relative path from this state node
   * @param historyValue
   */
  getFromRelativePath(
    relativePath: string[],
  ): Array<StateNode<TContext, any, TEvent, any>>;
  private historyValue;
  /**
   * Resolves to the historical value(s) of the parent state node,
   * represented by state nodes.
   *
   * @param historyValue
   */
  private resolveHistory;
  /**
   * All the state node IDs of this state node and its descendant state nodes.
   */
  get stateIds(): string[];
  /**
   * All the event types accepted by this state node and its descendants.
   */
  get events(): Array<TEvent['type']>;
  /**
   * All the events that have transitions directly from this state node.
   *
   * Excludes any inert events.
   */
  get ownEvents(): Array<TEvent['type']>;
  private resolveTarget;
  private formatTransition;
  private formatTransitions;
}
interface Actor<TContext = any, TEvent extends EventObject = AnyEventObject>
  extends Subscribable<TContext> {
  id: string;
  send: (event: TEvent) => any;
  stop?: () => any | undefined;
  toJSON: () => {
    id: string;
  };
  meta?: InvokeDefinition<TContext, TEvent>;
  state?: any;
  deferred?: boolean;
}
declare type StateListener<
  TContext,
  TEvent extends EventObject,
  TStateSchema extends StateSchema<TContext> = any,
  TTypestate extends Typestate<TContext> = {
    value: any;
    context: TContext;
  },
> = (
  state: State<TContext, TEvent, TStateSchema, TTypestate>,
  event: TEvent,
) => void;
declare type ContextListener<TContext = DefaultContext> = (
  context: TContext,
  prevContext: TContext | undefined,
) => void;
declare type EventListener<TEvent extends EventObject = EventObject> = (
  event: TEvent,
) => void;
declare type Listener = () => void;
interface Clock {
  setTimeout(fn: (...args: any[]) => void, timeout: number): any;
  clearTimeout(id: any): void;
}
interface SpawnOptions {
  name?: string;
  autoForward?: boolean;
  sync?: boolean;
}
declare enum InterpreterStatus {
  NotStarted = 0,
  Running = 1,
  Stopped = 2,
}
declare class Interpreter<
  TContext,
  TStateSchema extends StateSchema = any,
  TEvent extends EventObject = EventObject,
  TTypestate extends Typestate<TContext> = {
    value: any;
    context: TContext;
  },
> implements Actor<State<TContext, TEvent, TStateSchema, TTypestate>, TEvent>
{
  machine: StateMachine<TContext, TStateSchema, TEvent, TTypestate>;
  /**
   * The default interpreter options:
   *
   * - `clock` uses the global `setTimeout` and `clearTimeout` functions
   * - `logger` uses the global `console.log()` method
   */
  static defaultOptions: InterpreterOptions;
  /**
   * The current state of the interpreted machine.
   */
  private _state?;
  private _initialState?;
  /**
   * The clock that is responsible for setting and clearing timeouts, such as delayed events and transitions.
   */
  clock: Clock;
  options: Readonly<InterpreterOptions>;
  private scheduler;
  private delayedEventsMap;
  private listeners;
  private contextListeners;
  private stopListeners;
  private doneListeners;
  private eventListeners;
  private sendListeners;
  private logger;
  /**
   * Whether the service is started.
   */
  initialized: boolean;
  status: InterpreterStatus;
  parent?: Interpreter<any>;
  id: string;
  /**
   * The globally unique process ID for this invocation.
   */
  sessionId: string;
  children: Map<string | number, SpawnedActorRef<any>>;
  private forwardTo;
  private devTools?;
  /**
   * Creates a new Interpreter instance (i.e., service) for the given machine with the provided options, if any.
   *
   * @param machine The machine to be interpreted
   * @param options Interpreter options
   */
  constructor(
    machine: StateMachine<TContext, TStateSchema, TEvent, TTypestate>,
    options?: Partial<InterpreterOptions>,
  );
  get initialState(): State<TContext, TEvent, TStateSchema, TTypestate>;
  get state(): State<TContext, TEvent, TStateSchema, TTypestate>;
  static interpret: typeof interpret;
  /**
   * Executes the actions of the given state, with that state's `context` and `event`.
   *
   * @param state The state whose actions will be executed
   * @param actionsConfig The action implementations to use
   */
  execute(
    state: State<TContext, TEvent, TStateSchema, TTypestate>,
    actionsConfig?: MachineOptions<TContext, TEvent>['actions'],
  ): void;
  private update;
  onTransition(
    listener: StateListener<TContext, TEvent, TStateSchema, TTypestate>,
  ): this;
  subscribe(
    observer: Observer<State<TContext, TEvent, any, TTypestate>>,
  ): Subscription;
  subscribe(
    nextListener?: (state: State<TContext, TEvent, any, TTypestate>) => void,
    errorListener?: (error: any) => void,
    completeListener?: () => void,
  ): Subscription;
  /**
   * Adds an event listener that is notified whenever an event is sent to the running interpreter.
   * @param listener The event listener
   */
  onEvent(
    listener: EventListener,
  ): Interpreter<TContext, TStateSchema, TEvent, TTypestate>;
  /**
   * Adds an event listener that is notified whenever a `send` event occurs.
   * @param listener The event listener
   */
  onSend(
    listener: EventListener,
  ): Interpreter<TContext, TStateSchema, TEvent, TTypestate>;
  /**
   * Adds a context listener that is notified whenever the state context changes.
   * @param listener The context listener
   */
  onChange(
    listener: ContextListener<TContext>,
  ): Interpreter<TContext, TStateSchema, TEvent, TTypestate>;
  /**
   * Adds a listener that is notified when the machine is stopped.
   * @param listener The listener
   */
  onStop(
    listener: Listener,
  ): Interpreter<TContext, TStateSchema, TEvent, TTypestate>;
  /**
   * Adds a state listener that is notified when the statechart has reached its final state.
   * @param listener The state listener
   */
  onDone(
    listener: EventListener<DoneEvent>,
  ): Interpreter<TContext, TStateSchema, TEvent, TTypestate>;
  /**
   * Removes a listener.
   * @param listener The listener to remove
   */
  off(
    listener: (...args: any[]) => void,
  ): Interpreter<TContext, TStateSchema, TEvent, TTypestate>;
  /**
   * Alias for Interpreter.prototype.start
   */
  init: (
    initialState?:
      | string
      | StateValueMap
      | State<TContext, TEvent, TStateSchema, TTypestate>
      | undefined,
  ) => Interpreter<TContext, TStateSchema, TEvent, TTypestate>;
  /**
   * Starts the interpreter from the given state, or the initial state.
   * @param initialState The state to start the statechart from
   */
  start(
    initialState?:
      | State<TContext, TEvent, TStateSchema, TTypestate>
      | StateValue,
  ): Interpreter<TContext, TStateSchema, TEvent, TTypestate>;
  /**
   * Stops the interpreter and unsubscribe all listeners.
   *
   * This will also notify the `onStop` listeners.
   */
  stop(): Interpreter<TContext, TStateSchema, TEvent, TTypestate>;
  /**
   * Sends an event to the running interpreter to trigger a transition.
   *
   * An array of events (batched) can be sent as well, which will send all
   * batched events to the running interpreter. The listeners will be
   * notified only **once** when all events are processed.
   *
   * @param event The event(s) to send
   */
  send: (
    event: SingleOrArray<Event<TEvent>> | SCXML.Event<TEvent>,
    payload?: EventData | undefined,
  ) => State<TContext, TEvent, TStateSchema, TTypestate>;
  private batch;
  /**
   * Returns a send function bound to this interpreter instance.
   *
   * @param event The event to be sent by the sender.
   */
  sender(
    event: Event<TEvent>,
  ): () => State<TContext, TEvent, TStateSchema, TTypestate>;
  private sendTo;
  /**
   * Returns the next state given the interpreter's current state and the event.
   *
   * This is a pure method that does _not_ update the interpreter's state.
   *
   * @param event The event to determine the next state
   */
  nextState(
    event: Event<TEvent> | SCXML.Event<TEvent>,
  ): State<TContext, TEvent, TStateSchema, TTypestate>;
  private forward;
  private defer;
  private cancel;
  private exec;
  private removeChild;
  private stopChild;
  spawn(
    entity: Spawnable,
    name: string,
    options?: SpawnOptions,
  ): SpawnedActorRef<any>;
  spawnMachine<
    TChildContext,
    TChildStateSchema,
    TChildEvent extends EventObject,
  >(
    machine: StateMachine<TChildContext, TChildStateSchema, TChildEvent>,
    options?: {
      id?: string;
      autoForward?: boolean;
      sync?: boolean;
    },
  ): SpawnedActorRef<TChildEvent, State<TChildContext, TChildEvent>>;
  private spawnPromise;
  private spawnCallback;
  private spawnObservable;
  private spawnActor;
  private spawnActivity;
  private spawnEffect;
  private attachDev;
  toJSON(): {
    id: string;
  };
}
declare function spawn<TC, TE extends EventObject>(
  entity: StateMachine<TC, any, TE>,
  nameOrOptions?: string | SpawnOptions,
): ActorRefFrom<StateMachine<TC, any, TE>>;
declare function spawn(
  entity: Spawnable,
  nameOrOptions?: string | SpawnOptions,
): SpawnedActorRef<any>;
/**
 * Creates a new Interpreter instance for the given machine with the provided options, if any.
 *
 * @param machine The machine to interpret
 * @param options Interpreter options
 */
declare function interpret<
  TContext = DefaultContext,
  TStateSchema extends StateSchema = any,
  TEvent extends EventObject = EventObject,
  TTypestate extends Typestate<TContext> = {
    value: any;
    context: TContext;
  },
>(
  machine: StateMachine<TContext, TStateSchema, TEvent, TTypestate>,
  options?: Partial<InterpreterOptions>,
): Interpreter<TContext, TStateSchema, TEvent, TTypestate>;
declare type EventType = string;
declare type ActionType = string;
declare type MetaObject = Record<string, any>;
/**
 * The full definition of an event, with a string `type`.
 */
interface EventObject {
  /**
   * The type of event that is sent.
   */
  type: string;
}
interface AnyEventObject extends EventObject {
  [key: string]: any;
}
/**
 * The full definition of an action, with a string `type` and an
 * `exec` implementation function.
 */
interface ActionObject<TContext, TEvent extends EventObject> {
  /**
   * The type of action that is executed.
   */
  type: string;
  /**
   * The implementation for executing the action.
   */
  exec?: ActionFunction<TContext, TEvent>;
  [other: string]: any;
}
declare type DefaultContext = Record<string, any> | undefined;
declare type EventData = Record<string, any> & {
  type?: never;
};
/**
 * The specified string event types or the specified event objects.
 */
declare type Event<TEvent extends EventObject> = TEvent['type'] | TEvent;
interface ActionMeta<TContext, TEvent extends EventObject>
  extends StateMeta<TContext, TEvent> {
  action: ActionObject<TContext, TEvent>;
  _event: SCXML.Event<TEvent>;
}
interface AssignMeta<TContext, TEvent extends EventObject> {
  state?: State<TContext, TEvent>;
  action: AssignAction<TContext, TEvent>;
  _event: SCXML.Event<TEvent>;
}
declare type ActionFunction<TContext, TEvent extends EventObject> = (
  context: TContext,
  event: TEvent,
  meta: ActionMeta<TContext, TEvent>,
) => void;
interface ChooseConditon<TContext, TEvent extends EventObject> {
  cond?: Condition<TContext, TEvent>;
  actions: Actions<TContext, TEvent>;
}
declare type Action<TContext, TEvent extends EventObject> =
  | ActionType
  | ActionObject<TContext, TEvent>
  | ActionFunction<TContext, TEvent>;
declare type Actions<TContext, TEvent extends EventObject> = SingleOrArray<
  Action<TContext, TEvent>
>;
declare type StateKey = string | State<any>;
interface StateValueMap {
  [key: string]: StateValue;
}
/**
 * The string or object representing the state value relative to the parent state node.
 *
 * - For a child atomic state node, this is a string, e.g., `"pending"`.
 * - For complex state nodes, this is an object, e.g., `{ success: "someChildState" }`.
 */
declare type StateValue = string | StateValueMap;
declare type KeysWithStates<
  TStates extends Record<string, StateSchema> | undefined,
> = TStates extends object
  ? {
      [K in keyof TStates]-?: TStates[K] extends {
        states: object;
      }
        ? K
        : never;
    }[keyof TStates]
  : never;
declare type ExtractStateValue<
  TSchema extends Required<Pick<StateSchema<any>, 'states'>>,
> =
  | keyof TSchema['states']
  | (KeysWithStates<TSchema['states']> extends never
      ? never
      : {
          [K in KeysWithStates<TSchema['states']>]?: ExtractStateValue<
            TSchema['states'][K]
          >;
        });
interface HistoryValue {
  states: Record<string, HistoryValue | undefined>;
  current: StateValue | undefined;
}
declare type ConditionPredicate<TContext, TEvent extends EventObject> = (
  context: TContext,
  event: TEvent,
  meta: GuardMeta<TContext, TEvent>,
) => boolean;
declare type DefaultGuardType = 'xstate.guard';
interface GuardPredicate<TContext, TEvent extends EventObject> {
  type: DefaultGuardType;
  name: string | undefined;
  predicate: ConditionPredicate<TContext, TEvent>;
}
declare type Guard<TContext, TEvent extends EventObject> =
  | GuardPredicate<TContext, TEvent>
  | (Record<string, any> & {
      type: string;
    });
interface GuardMeta<TContext, TEvent extends EventObject>
  extends StateMeta<TContext, TEvent> {
  cond: Guard<TContext, TEvent>;
}
declare type Condition<TContext, TEvent extends EventObject> =
  | string
  | ConditionPredicate<TContext, TEvent>
  | Guard<TContext, TEvent>;
declare type TransitionTarget<TContext, TEvent extends EventObject> =
  SingleOrArray<string | StateNode<TContext, any, TEvent>>;
declare type TransitionTargets<TContext> = Array<
  string | StateNode<TContext, any>
>;
interface TransitionConfig<TContext, TEvent extends EventObject> {
  cond?: Condition<TContext, TEvent>;
  actions?: Actions<TContext, TEvent>;
  in?: StateValue;
  internal?: boolean;
  target?: TransitionTarget<TContext, TEvent>;
  meta?: Record<string, any>;
}
interface TargetTransitionConfig<TContext, TEvent extends EventObject>
  extends TransitionConfig<TContext, TEvent> {
  target: TransitionTarget<TContext, TEvent>;
}
declare type ConditionalTransitionConfig<
  TContext,
  TEvent extends EventObject = EventObject,
> = Array<TransitionConfig<TContext, TEvent>>;
declare type Transition<TContext, TEvent extends EventObject = EventObject> =
  | string
  | TransitionConfig<TContext, TEvent>
  | ConditionalTransitionConfig<TContext, TEvent>;
declare type DisposeActivityFunction = () => void;
declare type ActivityConfig<TContext, TEvent extends EventObject> = (
  ctx: TContext,
  activity: ActivityDefinition<TContext, TEvent>,
) => DisposeActivityFunction | void;
declare type Activity<TContext, TEvent extends EventObject> =
  | string
  | ActivityDefinition<TContext, TEvent>;
interface ActivityDefinition<TContext, TEvent extends EventObject>
  extends ActionObject<TContext, TEvent> {
  id: string;
  type: string;
}
declare type Sender<TEvent extends EventObject> = (
  event: Event<TEvent>,
) => void;
declare type ExcludeType<A> = {
  [K in Exclude<keyof A, 'type'>]: A[K];
};
declare type ExtractExtraParameters<A, T> = A extends {
  type: T;
}
  ? ExcludeType<A>
  : never;
declare type ExtractSimple<A> = A extends any
  ? {} extends ExcludeType<A>
    ? A
    : never
  : never;
declare type NeverIfEmpty<T> = {} extends T ? never : T;
interface PayloadSender<TEvent extends EventObject> {
  /**
   * Send an event object or just the event type, if the event has no other payload
   */
  (event: TEvent | ExtractSimple<TEvent>['type']): void;
  /**
   * Send an event type and its payload
   */
  <K extends TEvent['type']>(
    eventType: K,
    payload: NeverIfEmpty<ExtractExtraParameters<TEvent, K>>,
  ): void;
}
declare type Receiver<TEvent extends EventObject> = (
  listener: (event: TEvent) => void,
) => void;
declare type InvokeCallback<TEvent extends EventObject = AnyEventObject> = (
  callback: Sender<TEvent>,
  onReceive: Receiver<TEvent>,
) => any;
interface InvokeMeta {
  data: any;
  src: InvokeSourceDefinition;
}
/**
 * Returns either a Promises or a callback handler (for streams of events) given the
 * machine's current `context` and `event` that invoked the service.
 *
 * For Promises, the only events emitted to the parent will be:
 * - `done.invoke.<id>` with the `data` containing the resolved payload when the promise resolves, or:
 * - `error.platform.<id>` with the `data` containing the caught error, and `src` containing the service `id`.
 *
 * For callback handlers, the `callback` will be provided, which will send events to the parent service.
 *
 * @param context The current machine `context`
 * @param event The event that invoked the service
 */
declare type InvokeCreator<
  TContext,
  TEvent extends EventObject = AnyEventObject,
  TFinalContext = any,
> = (
  context: TContext,
  event: TEvent,
  meta: InvokeMeta,
) =>
  | PromiseLike<TFinalContext>
  | StateMachine<TFinalContext, any, any>
  | Subscribable<EventObject>
  | InvokeCallback<TEvent>;
interface InvokeDefinition<TContext, TEvent extends EventObject>
  extends ActivityDefinition<TContext, TEvent> {
  /**
   * The source of the machine to be invoked, or the machine itself.
   */
  src: string | InvokeSourceDefinition;
  /**
   * If `true`, events sent to the parent service will be forwarded to the invoked service.
   *
   * Default: `false`
   */
  autoForward?: boolean;
  /**
   * @deprecated
   *
   *  Use `autoForward` property instead of `forward`. Support for `forward` will get removed in the future.
   */
  forward?: boolean;
  /**
   * Data from the parent machine's context to set as the (partial or full) context
   * for the invoked child machine.
   *
   * Data should be mapped to match the child machine's context shape.
   */
  data?: Mapper<TContext, TEvent, any> | PropertyMapper<TContext, TEvent, any>;
}
interface Delay {
  id: string;
  /**
   * The time to delay the event, in milliseconds.
   */
  delay: number;
}
declare type DelayedTransitions<TContext, TEvent extends EventObject> =
  | Record<
      string | number,
      string | SingleOrArray<TransitionConfig<TContext, TEvent>>
    >
  | Array<
      TransitionConfig<TContext, TEvent> & {
        delay: number | string | Expr<TContext, TEvent, number>;
      }
    >;
declare type StateTypes =
  | 'atomic'
  | 'compound'
  | 'parallel'
  | 'final'
  | 'history'
  | string;
declare type SingleOrArray<T> = T[] | T;
declare type StateNodesConfig<
  TContext,
  TStateSchema extends StateSchema,
  TEvent extends EventObject,
> = {
  [K in keyof TStateSchema['states']]: StateNode<
    TContext,
    TStateSchema['states'][K],
    TEvent
  >;
};
declare type StatesConfig<
  TContext,
  TStateSchema extends StateSchema,
  TEvent extends EventObject,
> = {
  [K in keyof TStateSchema['states']]: StateNodeConfig<
    TContext,
    TStateSchema['states'][K],
    TEvent
  >;
};
declare type StatesDefinition<
  TContext,
  TStateSchema extends StateSchema,
  TEvent extends EventObject,
> = {
  [K in keyof TStateSchema['states']]: StateNodeDefinition<
    TContext,
    TStateSchema['states'][K],
    TEvent
  >;
};
declare type TransitionConfigTarget<TContext, TEvent extends EventObject> =
  | string
  | undefined
  | StateNode<TContext, any, TEvent>;
declare type TransitionConfigOrTarget<TContext, TEvent extends EventObject> =
  SingleOrArray<
    | TransitionConfigTarget<TContext, TEvent>
    | TransitionConfig<TContext, TEvent>
  >;
declare type TransitionsConfigMap<TContext, TEvent extends EventObject> = {
  [K in TEvent['type']]?: TransitionConfigOrTarget<
    TContext,
    TEvent extends {
      type: K;
    }
      ? TEvent
      : never
  >;
} & {
  ''?: TransitionConfigOrTarget<TContext, TEvent>;
} & {
  '*'?: TransitionConfigOrTarget<TContext, TEvent>;
};
declare type TransitionsConfigArray<TContext, TEvent extends EventObject> =
  Array<
    | (TEvent extends EventObject
        ? TransitionConfig<TContext, TEvent> & {
            event: TEvent['type'];
          }
        : never)
    | (TransitionConfig<TContext, TEvent> & {
        event: '';
      })
    | (TransitionConfig<TContext, TEvent> & {
        event: '*';
      })
  >;
declare type TransitionsConfig<TContext, TEvent extends EventObject> =
  | TransitionsConfigMap<TContext, TEvent>
  | TransitionsConfigArray<TContext, TEvent>;
interface InvokeSourceDefinition {
  [key: string]: any;
  type: string;
}
interface InvokeConfig<TContext, TEvent extends EventObject> {
  /**
   * The unique identifier for the invoked machine. If not specified, this
   * will be the machine's own `id`, or the URL (from `src`).
   */
  id?: string;
  /**
   * The source of the machine to be invoked, or the machine itself.
   */
  src:
    | string
    | InvokeSourceDefinition
    | StateMachine<any, any, any>
    | InvokeCreator<TContext, TEvent, any>;
  /**
   * If `true`, events sent to the parent service will be forwarded to the invoked service.
   *
   * Default: `false`
   */
  autoForward?: boolean;
  /**
   * @deprecated
   *
   *  Use `autoForward` property instead of `forward`. Support for `forward` will get removed in the future.
   */
  forward?: boolean;
  /**
   * Data from the parent machine's context to set as the (partial or full) context
   * for the invoked child machine.
   *
   * Data should be mapped to match the child machine's context shape.
   */
  data?: Mapper<TContext, TEvent, any> | PropertyMapper<TContext, TEvent, any>;
  /**
   * The transition to take upon the invoked child machine reaching its final top-level state.
   */
  onDone?:
    | string
    | SingleOrArray<TransitionConfig<TContext, DoneInvokeEvent<any>>>;
  /**
   * The transition to take upon the invoked child machine sending an error event.
   */
  onError?:
    | string
    | SingleOrArray<TransitionConfig<TContext, DoneInvokeEvent<any>>>;
}
interface StateNodeConfig<
  TContext,
  TStateSchema extends StateSchema,
  TEvent extends EventObject,
> {
  /**
   * The relative key of the state node, which represents its location in the overall state value.
   * This is automatically determined by the configuration shape via the key where it was defined.
   */
  key?: string;
  /**
   * The initial state node key.
   */
  initial?: keyof TStateSchema['states'] | undefined;
  /**
   * @deprecated
   */
  parallel?: boolean | undefined;
  /**
   * The type of this state node:
   *
   *  - `'atomic'` - no child state nodes
   *  - `'compound'` - nested child state nodes (XOR)
   *  - `'parallel'` - orthogonal nested child state nodes (AND)
   *  - `'history'` - history state node
   *  - `'final'` - final state node
   */
  type?: 'atomic' | 'compound' | 'parallel' | 'final' | 'history';
  /**
   * The initial context (extended state) of the machine.
   *
   * Can be an object or a function that returns an object.
   */
  context?: TContext | (() => TContext);
  /**
   * Indicates whether the state node is a history state node, and what
   * type of history:
   * shallow, deep, true (shallow), false (none), undefined (none)
   */
  history?: 'shallow' | 'deep' | boolean | undefined;
  /**
   * The mapping of state node keys to their state node configurations (recursive).
   */
  states?: StatesConfig<TContext, TStateSchema, TEvent> | undefined;
  /**
   * The services to invoke upon entering this state node. These services will be stopped upon exiting this state node.
   */
  invoke?: SingleOrArray<
    InvokeConfig<TContext, TEvent> | StateMachine<any, any, any>
  >;
  /**
   * The mapping of event types to their potential transition(s).
   */
  on?: TransitionsConfig<TContext, TEvent>;
  /**
   * The action(s) to be executed upon entering the state node.
   *
   * @deprecated Use `entry` instead.
   */
  onEntry?: Actions<TContext, TEvent>;
  /**
   * The action(s) to be executed upon entering the state node.
   */
  entry?: Actions<TContext, TEvent>;
  /**
   * The action(s) to be executed upon exiting the state node.
   *
   * @deprecated Use `exit` instead.
   */
  onExit?: Actions<TContext, TEvent>;
  /**
   * The action(s) to be executed upon exiting the state node.
   */
  exit?: Actions<TContext, TEvent>;
  /**
   * The potential transition(s) to be taken upon reaching a final child state node.
   *
   * This is equivalent to defining a `[done(id)]` transition on this state node's `on` property.
   */
  onDone?: string | SingleOrArray<TransitionConfig<TContext, DoneEventObject>>;
  /**
   * The mapping (or array) of delays (in milliseconds) to their potential transition(s).
   * The delayed transitions are taken after the specified delay in an interpreter.
   */
  after?: DelayedTransitions<TContext, TEvent>;
  /**
   * An eventless transition that is always taken when this state node is active.
   * Equivalent to a transition specified as an empty `''`' string in the `on` property.
   */
  always?: TransitionConfigOrTarget<TContext, TEvent>;
  /**
   * The activities to be started upon entering the state node,
   * and stopped upon exiting the state node.
   */
  activities?: SingleOrArray<Activity<TContext, TEvent>>;
  /**
   * @private
   */
  parent?: StateNode<TContext, any, TEvent>;
  strict?: boolean | undefined;
  /**
   * The meta data associated with this state node, which will be returned in State instances.
   */
  meta?: TStateSchema extends {
    meta: infer D;
  }
    ? D
    : any;
  /**
   * The data sent with the "done.state._id_" event if this is a final state node.
   *
   * The data will be evaluated with the current `context` and placed on the `.data` property
   * of the event.
   */
  data?: Mapper<TContext, TEvent, any> | PropertyMapper<TContext, TEvent, any>;
  /**
   * The unique ID of the state node, which can be referenced as a transition target via the
   * `#id` syntax.
   */
  id?: string | undefined;
  /**
   * The string delimiter for serializing the path to a string. The default is "."
   */
  delimiter?: string;
  /**
   * The order this state node appears. Corresponds to the implicit SCXML document order.
   */
  order?: number;
  /**
   * The tags for this state node, which are accumulated into the `state.tags` property.
   */
  tags?: SingleOrArray<string>;
}
interface StateNodeDefinition<
  TContext,
  TStateSchema extends StateSchema,
  TEvent extends EventObject,
> {
  id: string;
  version: string | undefined;
  key: string;
  context: TContext;
  type: 'atomic' | 'compound' | 'parallel' | 'final' | 'history';
  initial: StateNodeConfig<TContext, TStateSchema, TEvent>['initial'];
  history: boolean | 'shallow' | 'deep' | undefined;
  states: StatesDefinition<TContext, TStateSchema, TEvent>;
  on: TransitionDefinitionMap<TContext, TEvent>;
  transitions: Array<TransitionDefinition<TContext, TEvent>>;
  entry: Array<ActionObject<TContext, TEvent>>;
  exit: Array<ActionObject<TContext, TEvent>>;
  activities: Array<ActivityDefinition<TContext, TEvent>>;
  meta: any;
  order: number;
  data?: FinalStateNodeConfig<TContext, TEvent>['data'];
  invoke: Array<InvokeDefinition<TContext, TEvent>>;
}
declare type AnyStateNodeDefinition = StateNodeDefinition<any, any, any>;
interface AtomicStateNodeConfig<TContext, TEvent extends EventObject>
  extends StateNodeConfig<TContext, StateSchema, TEvent> {
  initial?: undefined;
  parallel?: false | undefined;
  states?: undefined;
  onDone?: undefined;
}
interface HistoryStateNodeConfig<TContext, TEvent extends EventObject>
  extends AtomicStateNodeConfig<TContext, TEvent> {
  history: 'shallow' | 'deep' | true;
  target: StateValue | undefined;
}
interface FinalStateNodeConfig<TContext, TEvent extends EventObject>
  extends AtomicStateNodeConfig<TContext, TEvent> {
  type: 'final';
  /**
   * The data to be sent with the "done.state.<id>" event. The data can be
   * static or dynamic (based on assigners).
   */
  data?: Mapper<TContext, TEvent, any> | PropertyMapper<TContext, TEvent, any>;
}
declare type SimpleOrStateNodeConfig<
  TContext,
  TStateSchema extends StateSchema,
  TEvent extends EventObject,
> =
  | AtomicStateNodeConfig<TContext, TEvent>
  | StateNodeConfig<TContext, TStateSchema, TEvent>;
declare type ActionFunctionMap<TContext, TEvent extends EventObject> = Record<
  string,
  ActionObject<TContext, TEvent> | ActionFunction<TContext, TEvent>
>;
declare type DelayFunctionMap<TContext, TEvent extends EventObject> = Record<
  string,
  DelayConfig<TContext, TEvent>
>;
declare type ServiceConfig<
  TContext,
  TEvent extends EventObject = AnyEventObject,
> = string | StateMachine<any, any, any> | InvokeCreator<TContext, TEvent>;
declare type DelayConfig<TContext, TEvent extends EventObject> =
  | number
  | DelayExpr<TContext, TEvent>;
interface MachineOptions<TContext, TEvent extends EventObject> {
  guards: Record<string, ConditionPredicate<TContext, TEvent>>;
  actions: ActionFunctionMap<TContext, TEvent>;
  activities: Record<string, ActivityConfig<TContext, TEvent>>;
  services: Record<string, ServiceConfig<TContext, TEvent>>;
  delays: DelayFunctionMap<TContext, TEvent>;
  /**
   * @private
   */
  _parent?: StateNode<TContext, any, TEvent, any>;
  /**
   * @private
   */
  _key?: string;
}
interface MachineConfig<
  TContext,
  TStateSchema extends StateSchema,
  TEvent extends EventObject,
> extends StateNodeConfig<TContext, TStateSchema, TEvent> {
  /**
   * The initial context (extended state)
   */
  context?: TContext | (() => TContext);
  /**
   * The machine's own version.
   */
  version?: string;
  schema?: MachineSchema<TContext, TEvent>;
}
interface MachineSchema<TContext, TEvent extends EventObject> {
  context?: TContext;
  events?: TEvent;
  actions?: {
    type: string;
    [key: string]: any;
  };
  guards?: {
    type: string;
    [key: string]: any;
  };
  services?: {
    type: string;
    [key: string]: any;
  };
}
interface StandardMachineConfig<
  TContext,
  TStateSchema extends StateSchema,
  TEvent extends EventObject,
> extends StateNodeConfig<TContext, TStateSchema, TEvent> {}
interface ParallelMachineConfig<
  TContext,
  TStateSchema extends StateSchema,
  TEvent extends EventObject,
> extends StateNodeConfig<TContext, TStateSchema, TEvent> {
  initial?: undefined;
  type?: 'parallel';
}
interface EntryExitEffectMap<TContext, TEvent extends EventObject> {
  entry: Array<ActionObject<TContext, TEvent>>;
  exit: Array<ActionObject<TContext, TEvent>>;
}
interface HistoryStateNode<TContext> extends StateNode<TContext> {
  history: 'shallow' | 'deep';
  target: StateValue | undefined;
}
interface StateMachine<
  TContext,
  TStateSchema extends StateSchema,
  TEvent extends EventObject,
  TTypestate extends Typestate<TContext> = {
    value: any;
    context: TContext;
  },
> extends StateNode<TContext, TStateSchema, TEvent, TTypestate> {
  id: string;
  states: StateNode<TContext, TStateSchema, TEvent>['states'];
}
declare type StateFrom<TMachine extends StateMachine<any, any, any>> =
  ReturnType<TMachine['transition']>;
interface ActionMap<TContext, TEvent extends EventObject> {
  onEntry: Array<Action<TContext, TEvent>>;
  actions: Array<Action<TContext, TEvent>>;
  onExit: Array<Action<TContext, TEvent>>;
}
interface EntryExitStates<TContext> {
  entry: Set<StateNode<TContext>>;
  exit: Set<StateNode<TContext>>;
}
interface EntryExitStateArrays<TContext> {
  entry: Array<StateNode<TContext>>;
  exit: Array<StateNode<TContext>>;
}
interface ActivityMap {
  [activityKey: string]: ActivityDefinition<any, any> | false;
}
interface StateTransition<TContext, TEvent extends EventObject> {
  transitions: Array<TransitionDefinition<TContext, TEvent>>;
  configuration: Array<StateNode<TContext, any, TEvent, any>>;
  entrySet: Array<StateNode<TContext, any, TEvent, any>>;
  exitSet: Array<StateNode<TContext, any, TEvent, any>>;
  /**
   * The source state that preceded the transition.
   */
  source: State<TContext, any, any, any> | undefined;
  actions: Array<ActionObject<TContext, TEvent>>;
}
interface TransitionData<TContext, TEvent extends EventObject> {
  value: StateValue | undefined;
  actions: ActionMap<TContext, TEvent>;
  activities?: ActivityMap;
}
declare enum ActionTypes {
  Start = 'xstate.start',
  Stop = 'xstate.stop',
  Raise = 'xstate.raise',
  Send = 'xstate.send',
  Cancel = 'xstate.cancel',
  NullEvent = '',
  Assign = 'xstate.assign',
  After = 'xstate.after',
  DoneState = 'done.state',
  DoneInvoke = 'done.invoke',
  Log = 'xstate.log',
  Init = 'xstate.init',
  Invoke = 'xstate.invoke',
  ErrorExecution = 'error.execution',
  ErrorCommunication = 'error.communication',
  ErrorPlatform = 'error.platform',
  ErrorCustom = 'xstate.error',
  Update = 'xstate.update',
  Pure = 'xstate.pure',
  Choose = 'xstate.choose',
}
interface RaiseAction<TEvent extends EventObject> {
  type: ActionTypes.Raise;
  event: TEvent['type'];
}
interface RaiseActionObject<TEvent extends EventObject> {
  type: ActionTypes.Raise;
  _event: SCXML.Event<TEvent>;
}
interface DoneInvokeEvent<TData> extends EventObject {
  data: TData;
}
interface ErrorExecutionEvent extends EventObject {
  src: string;
  type: ActionTypes.ErrorExecution;
  data: any;
}
interface ErrorPlatformEvent extends EventObject {
  data: any;
}
interface DoneEventObject extends EventObject {
  data?: any;
  toString(): string;
}
interface UpdateObject extends EventObject {
  id: string | number;
  state: State<any, any>;
}
declare type DoneEvent = DoneEventObject & string;
interface NullEvent {
  type: ActionTypes.NullEvent;
}
interface ActivityActionObject<TContext, TEvent extends EventObject>
  extends ActionObject<TContext, TEvent> {
  type: ActionTypes.Start | ActionTypes.Stop;
  activity: ActivityDefinition<TContext, TEvent> | undefined;
  exec: ActionFunction<TContext, TEvent> | undefined;
}
interface InvokeActionObject<TContext, TEvent extends EventObject>
  extends ActivityActionObject<TContext, TEvent> {
  activity: InvokeDefinition<TContext, TEvent>;
}
declare type DelayExpr<TContext, TEvent extends EventObject> = ExprWithMeta<
  TContext,
  TEvent,
  number
>;
declare type LogExpr<TContext, TEvent extends EventObject> = ExprWithMeta<
  TContext,
  TEvent,
  any
>;
interface LogAction<TContext, TEvent extends EventObject>
  extends ActionObject<TContext, TEvent> {
  label: string | undefined;
  expr: string | LogExpr<TContext, TEvent>;
}
interface LogActionObject<TContext, TEvent extends EventObject>
  extends LogAction<TContext, TEvent> {
  value: any;
}
interface SendAction<
  TContext,
  TEvent extends EventObject,
  TSentEvent extends EventObject,
> extends ActionObject<TContext, TEvent> {
  to:
    | string
    | number
    | ActorRef<any>
    | ExprWithMeta<TContext, TEvent, string | number | ActorRef<any>>
    | undefined;
  event: TSentEvent | SendExpr<TContext, TEvent, TSentEvent>;
  delay?: number | string | DelayExpr<TContext, TEvent>;
  id: string | number;
}
interface SendActionObject<
  TContext,
  TEvent extends EventObject,
  TSentEvent extends EventObject = AnyEventObject,
> extends SendAction<TContext, TEvent, TSentEvent> {
  to: string | number | ActorRef<any> | undefined;
  _event: SCXML.Event<TSentEvent>;
  event: TSentEvent;
  delay?: number;
  id: string | number;
}
interface StopAction<TContext, TEvent extends EventObject>
  extends ActionObject<TContext, TEvent> {
  type: ActionTypes.Stop;
  activity:
    | string
    | {
        id: string;
      }
    | Expr<
        TContext,
        TEvent,
        | string
        | {
            id: string;
          }
      >;
}
interface StopActionObject {
  type: ActionTypes.Stop;
  activity: {
    id: string;
  };
}
declare type Expr<TContext, TEvent extends EventObject, T> = (
  context: TContext,
  event: TEvent,
) => T;
declare type ExprWithMeta<TContext, TEvent extends EventObject, T> = (
  context: TContext,
  event: TEvent,
  meta: SCXMLEventMeta<TEvent>,
) => T;
declare type SendExpr<
  TContext,
  TEvent extends EventObject,
  TSentEvent extends EventObject = AnyEventObject,
> = ExprWithMeta<TContext, TEvent, TSentEvent>;
declare enum SpecialTargets {
  Parent = '#_parent',
  Internal = '#_internal',
}
interface SendActionOptions<TContext, TEvent extends EventObject> {
  id?: string | number;
  delay?: number | string | DelayExpr<TContext, TEvent>;
  to?: string | ExprWithMeta<TContext, TEvent, string | number | ActorRef<any>>;
}
interface CancelAction extends ActionObject<any, any> {
  sendId: string | number;
}
declare type Assigner<TContext, TEvent extends EventObject> = (
  context: TContext,
  event: TEvent,
  meta: AssignMeta<TContext, TEvent>,
) => Partial<TContext>;
declare type PartialAssigner<
  TContext,
  TEvent extends EventObject,
  TKey extends keyof TContext,
> = (
  context: TContext,
  event: TEvent,
  meta: AssignMeta<TContext, TEvent>,
) => TContext[TKey];
declare type PropertyAssigner<TContext, TEvent extends EventObject> = {
  [K in keyof TContext]?: PartialAssigner<TContext, TEvent, K> | TContext[K];
};
declare type Mapper<TContext, TEvent extends EventObject, TParams extends {}> =
  (context: TContext, event: TEvent) => TParams;
declare type PropertyMapper<
  TContext,
  TEvent extends EventObject,
  TParams extends {},
> = {
  [K in keyof TParams]?:
    | ((context: TContext, event: TEvent) => TParams[K])
    | TParams[K];
};
interface AnyAssignAction<TContext, TEvent extends EventObject>
  extends ActionObject<TContext, TEvent> {
  type: ActionTypes.Assign;
  assignment: any;
}
interface AssignAction<TContext, TEvent extends EventObject>
  extends ActionObject<TContext, TEvent> {
  type: ActionTypes.Assign;
  assignment: Assigner<TContext, TEvent> | PropertyAssigner<TContext, TEvent>;
}
interface PureAction<TContext, TEvent extends EventObject>
  extends ActionObject<TContext, TEvent> {
  type: ActionTypes.Pure;
  get: (
    context: TContext,
    event: TEvent,
  ) => SingleOrArray<ActionObject<TContext, TEvent>> | undefined;
}
interface ChooseAction<TContext, TEvent extends EventObject>
  extends ActionObject<TContext, TEvent> {
  type: ActionTypes.Choose;
  conds: Array<ChooseConditon<TContext, TEvent>>;
}
interface TransitionDefinition<TContext, TEvent extends EventObject>
  extends TransitionConfig<TContext, TEvent> {
  target: Array<StateNode<TContext, any, TEvent>> | undefined;
  source: StateNode<TContext, any, TEvent>;
  actions: Array<ActionObject<TContext, TEvent>>;
  cond?: Guard<TContext, TEvent>;
  eventType: TEvent['type'] | NullEvent['type'] | '*';
  toJSON: () => {
    target: string[] | undefined;
    source: string;
    actions: Array<ActionObject<TContext, TEvent>>;
    cond?: Guard<TContext, TEvent>;
    eventType: TEvent['type'] | NullEvent['type'] | '*';
    meta?: Record<string, any>;
  };
}
declare type TransitionDefinitionMap<TContext, TEvent extends EventObject> = {
  [K in TEvent['type'] | NullEvent['type'] | '*']: Array<
    TransitionDefinition<
      TContext,
      K extends TEvent['type']
        ? Extract<
            TEvent,
            {
              type: K;
            }
          >
        : EventObject
    >
  >;
};
interface DelayedTransitionDefinition<TContext, TEvent extends EventObject>
  extends TransitionDefinition<TContext, TEvent> {
  delay: number | string | DelayExpr<TContext, TEvent>;
}
interface Edge<
  TContext,
  TEvent extends EventObject,
  TEventType extends TEvent['type'] = string,
> {
  event: TEventType;
  source: StateNode<TContext, any, TEvent>;
  target: StateNode<TContext, any, TEvent>;
  cond?: Condition<
    TContext,
    TEvent & {
      type: TEventType;
    }
  >;
  actions: Array<Action<TContext, TEvent>>;
  meta?: MetaObject;
  transition: TransitionDefinition<TContext, TEvent>;
}
interface NodesAndEdges<TContext, TEvent extends EventObject> {
  nodes: StateNode[];
  edges: Array<Edge<TContext, TEvent, TEvent['type']>>;
}
interface Segment<TContext, TEvent extends EventObject> {
  /**
   * From state.
   */
  state: State<TContext, TEvent>;
  /**
   * Event from state.
   */
  event: TEvent;
}
interface PathItem<TContext, TEvent extends EventObject> {
  state: State<TContext, TEvent>;
  path: Array<Segment<TContext, TEvent>>;
  weight?: number;
}
interface PathMap<TContext, TEvent extends EventObject> {
  [key: string]: PathItem<TContext, TEvent>;
}
interface PathsItem<TContext, TEvent extends EventObject> {
  state: State<TContext, TEvent>;
  paths: Array<Array<Segment<TContext, TEvent>>>;
}
interface PathsMap<TContext, TEvent extends EventObject> {
  [key: string]: PathsItem<TContext, TEvent>;
}
interface TransitionMap {
  state: StateValue | undefined;
}
interface AdjacencyMap {
  [stateId: string]: Record<string, TransitionMap>;
}
interface ValueAdjacencyMap<TContext, TEvent extends EventObject> {
  [stateId: string]: Record<string, State<TContext, TEvent>>;
}
interface SCXMLEventMeta<TEvent extends EventObject> {
  _event: SCXML.Event<TEvent>;
}
interface StateMeta<TContext, TEvent extends EventObject> {
  state: State<TContext, TEvent, any, any>;
  _event: SCXML.Event<TEvent>;
}
interface Typestate<TContext> {
  value: StateValue;
  context: TContext;
}
interface StateLike<TContext> {
  value: StateValue;
  context: TContext;
  event: EventObject;
  _event: SCXML.Event<EventObject>;
}
interface StateConfig<TContext, TEvent extends EventObject> {
  value: StateValue;
  context: TContext;
  _event: SCXML.Event<TEvent>;
  _sessionid: string | null;
  historyValue?: HistoryValue | undefined;
  history?: State<TContext, TEvent>;
  actions?: Array<ActionObject<TContext, TEvent>>;
  activities?: ActivityMap;
  meta?: any;
  events?: TEvent[];
  configuration: Array<StateNode<TContext, any, TEvent>>;
  transitions: Array<TransitionDefinition<TContext, TEvent>>;
  children: Record<string, ActorRef<any>>;
  done?: boolean;
  tags?: Set<string>;
}
interface StateSchema<TC = any> {
  meta?: any;
  context?: Partial<TC>;
  states?: {
    [key: string]: StateSchema<TC>;
  };
}
interface InterpreterOptions {
  /**
   * Whether state actions should be executed immediately upon transition. Defaults to `true`.
   */
  execute: boolean;
  clock: Clock;
  logger: (...args: any[]) => void;
  parent?: AnyInterpreter;
  /**
   * If `true`, defers processing of sent events until the service
   * is initialized (`.start()`). Otherwise, an error will be thrown
   * for events sent to an uninitialized service.
   *
   * Default: `true`
   */
  deferEvents: boolean;
  /**
   * The custom `id` for referencing this service.
   */
  id?: string;
  /**
   * If `true`, states and events will be logged to Redux DevTools.
   *
   * Default: `false`
   */
  devTools: boolean | object;
  [option: string]: any;
}
declare namespace SCXML {
  interface Event<TEvent extends EventObject> {
    /**
     * This is a character string giving the name of the event.
     * The SCXML Processor must set the name field to the name of this event.
     * It is what is matched against the 'event' attribute of <transition>.
     * Note that transitions can do additional tests by using the value of this field
     * inside boolean expressions in the 'cond' attribute.
     */
    name: string;
    /**
     * This field describes the event type.
     * The SCXML Processor must set it to: "platform" (for events raised by the platform itself, such as error events),
     * "internal" (for events raised by <raise> and <send> with target '_internal')
     * or "external" (for all other events).
     */
    type: 'platform' | 'internal' | 'external';
    /**
     * If the sending entity has specified a value for this, the Processor must set this field to that value
     * (see C Event I/O Processors for details).
     * Otherwise, in the case of error events triggered by a failed attempt to send an event,
     * the Processor must set this field to the send id of the triggering <send> element.
     * Otherwise it must leave it blank.
     */
    sendid?: string;
    /**
     * This is a URI, equivalent to the 'target' attribute on the <send> element.
     * For external events, the SCXML Processor should set this field to a value which,
     * when used as the value of 'target', will allow the receiver of the event to <send>
     * a response back to the originating entity via the Event I/O Processor specified in 'origintype'.
     * For internal and platform events, the Processor must leave this field blank.
     */
    origin?: string;
    /**
     * This is equivalent to the 'type' field on the <send> element.
     * For external events, the SCXML Processor should set this field to a value which,
     * when used as the value of 'type', will allow the receiver of the event to <send>
     * a response back to the originating entity at the URI specified by 'origin'.
     * For internal and platform events, the Processor must leave this field blank.
     */
    origintype?: string;
    /**
     * If this event is generated from an invoked child process, the SCXML Processor
     * must set this field to the invoke id of the invocation that triggered the child process.
     * Otherwise it must leave it blank.
     */
    invokeid?: string;
    /**
     * This field contains whatever data the sending entity chose to include in this event.
     * The receiving SCXML Processor should reformat this data to match its data model,
     * but must not otherwise modify it.
     *
     * If the conversion is not possible, the Processor must leave the field blank
     * and must place an error 'error.execution' in the internal event queue.
     */
    data: TEvent;
    /**
     * @private
     */
    $$type: 'scxml';
  }
}
interface Observer<T> {
  next: (value: T) => void;
  error: (err: any) => void;
  complete: () => void;
}
interface Subscription {
  unsubscribe(): void;
}
interface Subscribable<T> {
  subscribe(observer: Observer<T>): Subscription;
  subscribe(
    next: (value: T) => void,
    error?: (error: any) => void,
    complete?: () => void,
  ): Subscription;
}
declare type Spawnable =
  | StateMachine<any, any, any>
  | Promise<any>
  | InvokeCallback
  | Subscribable<any>;
declare type ExtractEvent<
  TEvent extends EventObject,
  TEventType extends TEvent['type'],
> = TEvent extends {
  type: TEventType;
}
  ? TEvent
  : never;
interface ActorRef<TEvent extends EventObject, TEmitted = any>
  extends Subscribable<TEmitted> {
  send: Sender<TEvent>;
}
interface SpawnedActorRef<TEvent extends EventObject, TEmitted = any>
  extends ActorRef<TEvent, TEmitted> {
  id: string;
  stop?: () => void;
  toJSON?: () => any;
}
declare type ActorRefFrom<T extends StateMachine<any, any, any>> =
  T extends StateMachine<infer TContext, any, infer TEvent, infer TTypestate>
    ? SpawnedActorRef<TEvent, State<TContext, TEvent, any, TTypestate>> & {
        state: State<TContext, TEvent, any, TTypestate>;
      }
    : never;
declare type AnyInterpreter = Interpreter<any, any, any, any>;
declare type InterpreterFrom<T extends StateMachine<any, any, any, any>> =
  T extends StateMachine<
    infer TContext,
    infer TStateSchema,
    infer TEvent,
    infer TTypestate
  >
    ? Interpreter<TContext, TStateSchema, TEvent, TTypestate>
    : never;
declare function matchesState(
  parentStateId: StateValue,
  childStateId: StateValue,
  delimiter?: string,
): boolean;
declare function mapState(
  stateMap: {
    [stateId: string]: any;
  },
  stateId: string,
): any;
declare type Prop<T, K> = K extends keyof T ? T[K] : never;
interface Model<TContext, TEvent extends EventObject, TModelCreators = void> {
  initialContext: TContext;
  assign: <TEventType extends TEvent['type'] = TEvent['type']>(
    assigner:
      | Assigner<TContext, ExtractEvent<TEvent, TEventType>>
      | PropertyAssigner<TContext, ExtractEvent<TEvent, TEventType>>,
    eventType?: TEventType,
  ) => AssignAction<TContext, ExtractEvent<TEvent, TEventType>>;
  events: Prop<TModelCreators, 'events'>;
  reset: () => AssignAction<TContext, any>;
}
declare type ModelContextFrom<TModel extends Model<any, any, any>> =
  TModel extends Model<infer TContext, any, any> ? TContext : never;
declare type ModelEventsFrom<TModel extends Model<any, any, any>> =
  TModel extends Model<any, infer TEvent, any> ? TEvent : never;
declare function Machine<
  TContext = any,
  TEvent extends EventObject = AnyEventObject,
>(
  config: MachineConfig<TContext, any, TEvent>,
  options?: Partial<MachineOptions<TContext, TEvent>>,
  initialContext?: TContext,
): StateMachine<TContext, any, TEvent>;
declare function Machine<
  TContext = DefaultContext,
  TStateSchema extends StateSchema = any,
  TEvent extends EventObject = AnyEventObject,
>(
  config: MachineConfig<TContext, TStateSchema, TEvent>,
  options?: Partial<MachineOptions<TContext, TEvent>>,
  initialContext?: TContext,
): StateMachine<TContext, TStateSchema, TEvent>;
declare function createMachine<
  TModel extends Model<any, any, any>,
  TContext = ModelContextFrom<TModel>,
  TEvent extends EventObject = ModelEventsFrom<TModel>,
  TTypestate extends Typestate<TContext> = {
    value: any;
    context: TContext;
  },
>(
  config: MachineConfig<TContext, any, TEvent>,
  options?: Partial<MachineOptions<TContext, TEvent>>,
): StateMachine<TContext, any, TEvent, TTypestate>;
declare function createMachine<
  TContext,
  TEvent extends EventObject = AnyEventObject,
  TTypestate extends Typestate<TContext> = {
    value: any;
    context: TContext;
  },
>(
  config: MachineConfig<TContext, any, TEvent>,
  options?: Partial<MachineOptions<TContext, TEvent>>,
): StateMachine<TContext, any, TEvent, TTypestate>;
declare function raise<TContext, TEvent extends EventObject>(
  event: Event<TEvent>,
): RaiseAction<TEvent> | SendAction<TContext, AnyEventObject, TEvent>;
/**
 * Sends an event. This returns an action that will be read by an interpreter to
 * send the event in the next step, after the current step is finished executing.
 *
 * @param event The event to send.
 * @param options Options to pass into the send event:
 *  - `id` - The unique send event identifier (used with `cancel()`).
 *  - `delay` - The number of milliseconds to delay the sending of the event.
 *  - `to` - The target of this event (by default, the machine the event was sent from).
 */
declare function send<
  TContext,
  TEvent extends EventObject,
  TSentEvent extends EventObject = AnyEventObject,
>(
  event: Event<TSentEvent> | SendExpr<TContext, TEvent, TSentEvent>,
  options?: SendActionOptions<TContext, TEvent>,
): SendAction<TContext, TEvent, TSentEvent>;
/**
 * Sends an event to this machine's parent.
 *
 * @param event The event to send to the parent machine.
 * @param options Options to pass into the send event.
 */
declare function sendParent<
  TContext,
  TEvent extends EventObject,
  TSentEvent extends EventObject = AnyEventObject,
>(
  event: Event<TSentEvent> | SendExpr<TContext, TEvent, TSentEvent>,
  options?: SendActionOptions<TContext, TEvent>,
): SendAction<TContext, TEvent, TSentEvent>;
/**
 * Sends an update event to this machine's parent.
 */
declare function sendUpdate<TContext, TEvent extends EventObject>(): SendAction<
  TContext,
  TEvent,
  {
    type: ActionTypes.Update;
  }
>;
declare function respond<
  TContext,
  TEvent extends EventObject,
  TSentEvent extends EventObject = AnyEventObject,
>(
  event: Event<TEvent> | SendExpr<TContext, TEvent, TSentEvent>,
  options?: SendActionOptions<TContext, TEvent>,
): SendAction<TContext, TEvent, AnyEventObject>;
declare function log<TContext, TEvent extends EventObject>(
  expr?: string | LogExpr<TContext, TEvent>,
  label?: string,
): LogAction<TContext, TEvent>;
declare function start<TContext, TEvent extends EventObject>(
  activity: string | ActivityDefinition<TContext, TEvent>,
): ActivityActionObject<TContext, TEvent>;
declare function stop<TContext, TEvent extends EventObject>(
  actorRef:
    | string
    | ActivityDefinition<TContext, TEvent>
    | Expr<
        TContext,
        TEvent,
        | string
        | {
            id: string;
          }
      >,
): StopAction<TContext, TEvent>;
/**
 * Updates the current context of the machine.
 *
 * @param assignment An object that represents the partial context to update.
 */
declare const assign: <TContext, TEvent extends EventObject = EventObject>(
  assignment: Assigner<TContext, TEvent> | PropertyAssigner<TContext, TEvent>,
) => AssignAction<TContext, TEvent>;
declare function after(delayRef: number | string, id?: string): string;
declare function done(id: string, data?: any): DoneEventObject;
/**
 * Returns an event that represents that an invoked service has terminated.
 *
 * An invoked service is terminated when it has reached a top-level final state node,
 * but not when it is canceled.
 *
 * @param id The final state node ID
 * @param data The data to pass into the event
 */
declare function doneInvoke(id: string, data?: any): DoneEvent;
declare function pure<TContext, TEvent extends EventObject>(
  getActions: (
    context: TContext,
    event: TEvent,
  ) => SingleOrArray<ActionObject<TContext, TEvent>> | undefined,
): PureAction<TContext, TEvent>;
/**
 * Forwards (sends) an event to a specified service.
 *
 * @param target The target service to forward the event to.
 * @param options Options to pass into the send action creator.
 */
declare function forwardTo<TContext, TEvent extends EventObject>(
  target: Required<SendActionOptions<TContext, TEvent>>['to'],
  options?: SendActionOptions<TContext, TEvent>,
): SendAction<TContext, TEvent, AnyEventObject>;
declare function escalate<
  TContext,
  TEvent extends EventObject,
  TErrorData = any,
>(
  errorData: TErrorData | ExprWithMeta<TContext, TEvent, TErrorData>,
  options?: SendActionOptions<TContext, TEvent>,
): SendAction<TContext, TEvent, AnyEventObject>;
declare function choose<TContext, TEvent extends EventObject>(
  conds: Array<ChooseConditon<TContext, TEvent>>,
): ChooseAction<TContext, TEvent>;
declare type ValueFromStateGetter<T, TContext, TEvent extends EventObject> = (
  state: State<TContext, TEvent>,
) => T;
declare type StatePatternTuple<T, TContext, TEvent extends EventObject> = [
  StateValue,
  ValueFromStateGetter<T, TContext, TEvent>,
];
declare function matchState<T, TContext, TEvent extends EventObject>(
  state: State<TContext, TEvent> | StateValue,
  patterns: Array<StatePatternTuple<T, TContext, TEvent>>,
  defaultValue: ValueFromStateGetter<T, TContext, TEvent>,
): T;
declare function createSchema<T>(schema?: any): T;
declare const actions: {
  raise: typeof raise;
  send: typeof send;
  sendParent: typeof sendParent;
  sendUpdate: typeof sendUpdate;
  log: typeof log;
  cancel: (sendId: string | number) => CancelAction;
  start: typeof start;
  stop: typeof stop;
  assign: <TContext, TEvent extends EventObject = EventObject>(
    assignment: Assigner | PropertyAssigner,
  ) => AssignAction;
  after: typeof after;
  done: typeof done;
  respond: typeof respond;
  forwardTo: typeof forwardTo;
  escalate: typeof escalate;
  choose: typeof choose;
  pure: typeof pure;
};
