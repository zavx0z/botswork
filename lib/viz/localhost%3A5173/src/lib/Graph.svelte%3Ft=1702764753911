import { createHotContext as __vite__createHotContext } from "/@vite/client";import.meta.hot = __vite__createHotContext("/src/lib/Graph.svelte");/* src/lib/Graph.svelte generated by Svelte v4.2.8 */
import {
	SvelteComponentDev,
	add_location,
	attr_dev,
	check_outros,
	children,
	claim_component,
	claim_space,
	claim_svg_element,
	create_component,
	destroy_component,
	detach_dev,
	dispatch_dev,
	empty,
	ensure_array_like_dev,
	globals,
	group_outros,
	init,
	insert_hydration_dev,
	mount_component,
	outro_and_destroy_block,
	safe_not_equal,
	space,
	svg_element,
	transition_in,
	transition_out,
	update_keyed_each,
	validate_each_keys,
	validate_slots
} from "/node_modules/.vite/deps/svelte_internal.js?v=8b273cb8";

const { Map: Map_1, Object: Object_1 } = globals;
import "/node_modules/.vite/deps/svelte_internal_disclose-version.js?v=8b273cb8";
import __vite__cjsImport2_elkjs from "/node_modules/.vite/deps/elkjs.js?v=8b273cb8"; const ELK = __vite__cjsImport2_elkjs.__esModule ? __vite__cjsImport2_elkjs.default : __vite__cjsImport2_elkjs;
import { onMount, tick } from "/node_modules/.vite/deps/svelte.js?v=8b273cb8";
import State from "/src/lib/State.svelte?t=1702676564221";
import Edge from "/src/lib/Edge.svelte?t=1702667462145";
import Transition from "/src/lib/Transition.svelte?t=1702667494705";
const file = "src/lib/Graph.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[13] = list[i][0];
	child_ctx[14] = list[i][1];
	return child_ctx;
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[13] = list[i][0];
	child_ctx[14] = list[i][1];
	child_ctx[18] = i;
	return child_ctx;
}

function get_each_context_2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[13] = list[i][0];
	child_ctx[19] = list[i][1];
	return child_ctx;
}

// (223:0) {#each Object.entries(nodes) as [id, node] (id)}
function create_each_block_2(key_1, ctx) {
	let first;
	let state;
	let current;

	state = new State({
			props: {
				node: /*node*/ ctx[19],
				previewIds: /*previewIds*/ ctx[4],
				activeIds: /*activeIds*/ ctx[3]
			},
			$$inline: true
		});

	const block = {
		key: key_1,
		first: null,
		c: function create() {
			first = empty();
			create_component(state.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			first = empty();
			claim_component(state.$$.fragment, nodes);
			this.h();
		},
		h: function hydrate() {
			this.first = first;
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, first, anchor);
			mount_component(state, target, anchor);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			const state_changes = {};
			if (dirty & /*nodes*/ 2) state_changes.node = /*node*/ ctx[19];
			if (dirty & /*previewIds*/ 16) state_changes.previewIds = /*previewIds*/ ctx[4];
			if (dirty & /*activeIds*/ 8) state_changes.activeIds = /*activeIds*/ ctx[3];
			state.$set(state_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(state.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(state.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(first);
			}

			destroy_component(state, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_2.name,
		type: "each",
		source: "(223:0) {#each Object.entries(nodes) as [id, node] (id)}",
		ctx
	});

	return block;
}

// (227:2) {#each Object.entries(edges) as [id, edge], order (id)}
function create_each_block_1(key_1, ctx) {
	let first;
	let edge_1;
	let current;

	edge_1 = new Edge({
			props: {
				edge: /*edge*/ ctx[14],
				nodes: /*nodes*/ ctx[1],
				activeIds: /*activeIds*/ ctx[3],
				order: /*order*/ ctx[18]
			},
			$$inline: true
		});

	const block = {
		key: key_1,
		first: null,
		c: function create() {
			first = empty();
			create_component(edge_1.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			first = empty();
			claim_component(edge_1.$$.fragment, nodes);
			this.h();
		},
		h: function hydrate() {
			this.first = first;
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, first, anchor);
			mount_component(edge_1, target, anchor);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			const edge_1_changes = {};
			if (dirty & /*edges*/ 1) edge_1_changes.edge = /*edge*/ ctx[14];
			if (dirty & /*nodes*/ 2) edge_1_changes.nodes = /*nodes*/ ctx[1];
			if (dirty & /*activeIds*/ 8) edge_1_changes.activeIds = /*activeIds*/ ctx[3];
			if (dirty & /*edges*/ 1) edge_1_changes.order = /*order*/ ctx[18];
			edge_1.$set(edge_1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(edge_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(edge_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(first);
			}

			destroy_component(edge_1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_1.name,
		type: "each",
		source: "(227:2) {#each Object.entries(edges) as [id, edge], order (id)}",
		ctx
	});

	return block;
}

// (231:0) {#each Object.entries(edges) as [id, edge] (id)}
function create_each_block(key_1, ctx) {
	let first;
	let transition;
	let current;

	transition = new Transition({
			props: {
				edge: /*edge*/ ctx[14],
				activeIds: /*activeIds*/ ctx[3],
				actor: /*actor*/ ctx[2]
			},
			$$inline: true
		});

	const block = {
		key: key_1,
		first: null,
		c: function create() {
			first = empty();
			create_component(transition.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			first = empty();
			claim_component(transition.$$.fragment, nodes);
			this.h();
		},
		h: function hydrate() {
			this.first = first;
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, first, anchor);
			mount_component(transition, target, anchor);
			current = true;
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			const transition_changes = {};
			if (dirty & /*edges*/ 1) transition_changes.edge = /*edge*/ ctx[14];
			if (dirty & /*activeIds*/ 8) transition_changes.activeIds = /*activeIds*/ ctx[3];
			if (dirty & /*actor*/ 4) transition_changes.actor = /*actor*/ ctx[2];
			transition.$set(transition_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(transition.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(transition.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(first);
			}

			destroy_component(transition, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(231:0) {#each Object.entries(edges) as [id, edge] (id)}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let each_blocks_2 = [];
	let each0_lookup = new Map_1();
	let t0;
	let svg;
	let each_blocks_1 = [];
	let each1_lookup = new Map_1();
	let t1;
	let each_blocks = [];
	let each2_lookup = new Map_1();
	let each2_anchor;
	let current;
	let each_value_2 = ensure_array_like_dev(Object.entries(/*nodes*/ ctx[1]));
	const get_key = ctx => /*id*/ ctx[13];
	validate_each_keys(ctx, each_value_2, get_each_context_2, get_key);

	for (let i = 0; i < each_value_2.length; i += 1) {
		let child_ctx = get_each_context_2(ctx, each_value_2, i);
		let key = get_key(child_ctx);
		each0_lookup.set(key, each_blocks_2[i] = create_each_block_2(key, child_ctx));
	}

	let each_value_1 = ensure_array_like_dev(Object.entries(/*edges*/ ctx[0]));
	const get_key_1 = ctx => /*id*/ ctx[13];
	validate_each_keys(ctx, each_value_1, get_each_context_1, get_key_1);

	for (let i = 0; i < each_value_1.length; i += 1) {
		let child_ctx = get_each_context_1(ctx, each_value_1, i);
		let key = get_key_1(child_ctx);
		each1_lookup.set(key, each_blocks_1[i] = create_each_block_1(key, child_ctx));
	}

	let each_value = ensure_array_like_dev(Object.entries(/*edges*/ ctx[0]));
	const get_key_2 = ctx => /*id*/ ctx[13];
	validate_each_keys(ctx, each_value, get_each_context, get_key_2);

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context(ctx, each_value, i);
		let key = get_key_2(child_ctx);
		each2_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks_2.length; i += 1) {
				each_blocks_2[i].c();
			}

			t0 = space();
			svg = svg_element("svg");

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].c();
			}

			t1 = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each2_anchor = empty();
			this.h();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks_2.length; i += 1) {
				each_blocks_2[i].l(nodes);
			}

			t0 = claim_space(nodes);
			svg = claim_svg_element(nodes, "svg", { class: true });
			var svg_nodes = children(svg);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].l(svg_nodes);
			}

			svg_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each2_anchor = empty();
			this.h();
		},
		h: function hydrate() {
			attr_dev(svg, "class", "pointer-events-none fixed left-0 top-0 h-screen w-screen overflow-visible");
			add_location(svg, file, 257, 0, 7182);
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks_2.length; i += 1) {
				if (each_blocks_2[i]) {
					each_blocks_2[i].m(target, anchor);
				}
			}

			insert_hydration_dev(target, t0, anchor);
			insert_hydration_dev(target, svg, anchor);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				if (each_blocks_1[i]) {
					each_blocks_1[i].m(svg, null);
				}
			}

			insert_hydration_dev(target, t1, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(target, anchor);
				}
			}

			insert_hydration_dev(target, each2_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*Object, nodes, previewIds, activeIds*/ 26) {
				each_value_2 = ensure_array_like_dev(Object.entries(/*nodes*/ ctx[1]));
				group_outros();
				validate_each_keys(ctx, each_value_2, get_each_context_2, get_key);
				each_blocks_2 = update_keyed_each(each_blocks_2, dirty, get_key, 1, ctx, each_value_2, each0_lookup, t0.parentNode, outro_and_destroy_block, create_each_block_2, t0, get_each_context_2);
				check_outros();
			}

			if (dirty & /*Object, edges, nodes, activeIds*/ 11) {
				each_value_1 = ensure_array_like_dev(Object.entries(/*edges*/ ctx[0]));
				group_outros();
				validate_each_keys(ctx, each_value_1, get_each_context_1, get_key_1);
				each_blocks_1 = update_keyed_each(each_blocks_1, dirty, get_key_1, 1, ctx, each_value_1, each1_lookup, svg, outro_and_destroy_block, create_each_block_1, null, get_each_context_1);
				check_outros();
			}

			if (dirty & /*Object, edges, activeIds, actor*/ 13) {
				each_value = ensure_array_like_dev(Object.entries(/*edges*/ ctx[0]));
				group_outros();
				validate_each_keys(ctx, each_value, get_each_context, get_key_2);
				each_blocks = update_keyed_each(each_blocks, dirty, get_key_2, 1, ctx, each_value, each2_lookup, each2_anchor.parentNode, outro_and_destroy_block, create_each_block, each2_anchor, get_each_context);
				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value_2.length; i += 1) {
				transition_in(each_blocks_2[i]);
			}

			for (let i = 0; i < each_value_1.length; i += 1) {
				transition_in(each_blocks_1[i]);
			}

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			for (let i = 0; i < each_blocks_2.length; i += 1) {
				transition_out(each_blocks_2[i]);
			}

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				transition_out(each_blocks_1[i]);
			}

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) {
				detach_dev(t0);
				detach_dev(svg);
				detach_dev(t1);
				detach_dev(each2_anchor);
			}

			for (let i = 0; i < each_blocks_2.length; i += 1) {
				each_blocks_2[i].d(detaching);
			}

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].d();
			}

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d(detaching);
			}
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function flatten(array) {
	return [].concat(...array);
}

function getChildren(stateNode) {
	if (!stateNode.states) return [];
	const children = Object.keys(stateNode.states).map(key => stateNode.states[key]);
	children.sort((a, b) => b.order - a.order);
	return children;
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Graph', slots, []);
	let { actor } = $$props;
	let { edges = {} } = $$props;
	let { nodes = {} } = $$props;
	let { digraph } = $$props;
	const elk = new ELK({ defaultLayoutOptions: {} });

	function getElkChild(node, rMap) {
		const layout = nodes[node.id].meta.layout;
		const edges2 = rMap[0].get(node.stateNode) || [];

		return {
			id: node.id,
			// Устанавливаем ширину и высоту узла, если у него нет детей
			...node.children.length
			? void 0
			: {
					width: layout.width,
					height: layout.height
				},
			children: node.children.map(childNode => getElkChild(childNode, rMap)),
			edges: edges2.map(getElkEdge),
			layoutOptions: {
				"elk.padding": `[top=${(layout.height || 0) + 30}, left=30, right=30, bottom=30]`,
				// Добавляем отступы вокруг узла
				hierarchyHandling: "INCLUDE_CHILDREN"
			}, // Включаем дочерние узлы в иерархию
			node
		}; // Сохраняем ссылку на исходный узел
		// absolutePosition: { x: 0, y: 0 }, Задаем начальную абсолютную позицию узла (относительно родителя)
	}

	const getElkEdge = edge => ({
		id: edge.id,
		// Устанавливаем источник и цель дуги
		sources: [edge.source],
		targets: [edge.target],
		// Добавляем метку на дугу с параметрами разметки
		labels: [
			{
				id: edge.id + "--label",
				// Уникальный ID метки
				width: edges[edge.id].label.width,
				// Ширина метки
				height: edges[edge.id].label.height,
				// Высота метки
				text: edge.label.text || "always",
				// Текст метки
				layoutOptions: {
					"edgeLabels.inline": "true",
					// встроенная метка
					"edgeLabels.placement": "CENTER"
				}, // расположение по центру
				
			}
		],
		edge,
		// Сохраняем ссылку на исходную дугу
		sections: []
	}); // Пока не задаем секции дуги (могут быть добавлены позже)

	function getRelativeNodeEdgeMap() {
		const map = /* @__PURE__ */
		new Map();

		const edgeMap = /* @__PURE__ */
		new Map();

		const getLCA = (source, target) => {
			if (source === target) return source.parent;

			const set = /* @__PURE__ */
			new Set();

			let node = source.parent;

			while (node) {
				set.add(node);
				node = node.parent;
			}

			node = target;

			while (node) {
				if (set.has(node)) return node;
				node = node.parent;
			}

			return source.machine;
		};

		Object.values(edges).forEach(edge => {
			const lca = getLCA(nodes[edge.source], nodes[edge.target]);
			if (!map.has(lca)) map.set(lca, []);
			map.get(lca).push(edge);
			edgeMap.set(edge.id, lca);
		});

		return [map, edgeMap];
	}

	async function getElkGraph(digraph2) {
		const rMap = getRelativeNodeEdgeMap();
		const rootEdges = rMap[0].get(void 0) || [];

		const elkNode = {
			id: "root",
			edges: rootEdges.map(getElkEdge),
			children: [getElkChild(digraph2, rMap)],
			layoutOptions: {
				"elk.hierarchyHandling": "INCLUDE_CHILDREN",
				"elk.algorithm": "layered",
				"elk.layered.crossingMinimization.semiInteractive": "true"
			}
		};

		const layoutElkNode = await elk.layout(elkNode);
		const stateNodeToElkNodeMap = /* @__PURE__ */ new Map();

		const setEdgeLayout = edge => {
			const lca = rMap[1].get(edge.id);
			const elkLca = lca && stateNodeToElkNodeMap.get(lca);
			$$invalidate(0, edges[edge.id].label.x = elkLca?.x || 0, edges);
			$$invalidate(0, edges[edge.id].label.y = elkLca?.y || 0, edges);

			if (edge.sections) {
				const translatedSections = elkLca
				? edge.sections.map(section => ({
						...section,
						startPoint: {
							x: section.startPoint.x + elkLca.absolutePosition.x,
							y: section.startPoint.y + elkLca.absolutePosition.y
						},
						endPoint: {
							x: section.endPoint.x + elkLca.absolutePosition.x,
							y: section.endPoint.y + elkLca.absolutePosition.y
						},
						bendPoints: section.bendPoints?.map(bendPoint => {
							return {
								x: bendPoint.x + elkLca.absolutePosition.x,
								y: bendPoint.y + elkLca.absolutePosition.y
							};
						})
					}))
				: edge.sections;

				if (translatedSections) edge.edge.sections = translatedSections;
			}

			edge.edge.label.x = (edge.labels?.[0].x || 0) + (elkLca?.absolutePosition.x || 0);
			edge.edge.label.y = (edge.labels?.[0].y || 0) + (elkLca?.absolutePosition.y || 0);
		};

		const setLayout = (elkNode2, parent) => {
			stateNodeToElkNodeMap.set(elkNode2.node.stateNode, elkNode2);

			elkNode2.absolutePosition = {
				x: (parent?.absolutePosition.x ?? 0) + elkNode2.x,
				y: (parent?.absolutePosition.y ?? 0) + elkNode2.y
			};

			elkNode2.node.stateNode.meta = {
				layout: {
					width: elkNode2.width,
					height: elkNode2.height,
					x: elkNode2.x,
					y: elkNode2.y
				}
			};

			$$invalidate(
				1,
				nodes[elkNode2.id].meta = {
					layout: {
						width: elkNode2.width,
						height: elkNode2.height,
						x: (parent?.absolutePosition.x ?? 0) + elkNode2.x,
						y: (parent?.absolutePosition.y ?? 0) + elkNode2.y
					}
				},
				nodes
			);

			elkNode2.edges?.forEach(edge => {
				setEdgeLayout(edge);
			});

			elkNode2.children?.forEach(cn => {
				setLayout(cn, elkNode2);
			});
		};

		layoutElkNode.edges?.forEach(setEdgeLayout);
		setLayout(layoutElkNode.children[0], void 0);
		return layoutElkNode.children[0];
	}

	function toDirectedGraph(stateNode) {
		const egs = flatten(stateNode.transitions.map((t, transitionIndex) => {
			const targets = t.target ? t.target : [stateNode];

			return targets.map((target, targetIndex) => {
				const edge = {
					id: `${stateNode.id}:${transitionIndex}:${targetIndex}`,
					source: stateNode.id,
					target: target.id,
					transition: t,
					sections: [],
					label: {
						text: t.eventType,
						x: 0,
						y: 0,
						width: 0,
						height: 0
					}
				};

				return edge;
			});
		}));

		const graph = {
			id: stateNode.id,
			stateNode,
			children: getChildren(stateNode).map(toDirectedGraph),
			edges: egs
		};

		$$invalidate(1, nodes[graph.id] = graph.stateNode, nodes);
		return graph;
	}

	onMount(async () => {
		const machine = actor.getSnapshot().context.machine;
		let d = toDirectedGraph(machine);
		await tick();
		const elkg = await getElkGraph(d);
	});

	let activeIds = actor.getSnapshot().context.state.configuration.map(i => i.id);
	let previewIds = [];

	onMount(() => {
		const { unsubscribe } = actor.subscribe(state => {
			if (state.changed) {
				$$invalidate(4, previewIds = state.context.previewEvent
				? state.context.machine.transition(state.context.state, { type: state.context.previewEvent }).configuration.map(i => i.id)
				: []);

				$$invalidate(3, activeIds = state.context.state.configuration.map(i => i.id));
			}
		});

		return () => {
			unsubscribe();
		};
	});

	$$self.$$.on_mount.push(function () {
		if (actor === undefined && !('actor' in $$props || $$self.$$.bound[$$self.$$.props['actor']])) {
			console.warn("<Graph> was created without expected prop 'actor'");
		}

		if (digraph === undefined && !('digraph' in $$props || $$self.$$.bound[$$self.$$.props['digraph']])) {
			console.warn("<Graph> was created without expected prop 'digraph'");
		}
	});

	const writable_props = ['actor', 'edges', 'nodes', 'digraph'];

	Object_1.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Graph> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('actor' in $$props) $$invalidate(2, actor = $$props.actor);
		if ('edges' in $$props) $$invalidate(0, edges = $$props.edges);
		if ('nodes' in $$props) $$invalidate(1, nodes = $$props.nodes);
		if ('digraph' in $$props) $$invalidate(5, digraph = $$props.digraph);
	};

	$$self.$capture_state = () => ({
		ELK,
		onMount,
		tick,
		State,
		Edge,
		Transition,
		actor,
		edges,
		nodes,
		digraph,
		elk,
		getElkChild,
		getElkEdge,
		getRelativeNodeEdgeMap,
		getElkGraph,
		flatten,
		getChildren,
		toDirectedGraph,
		activeIds,
		previewIds
	});

	$$self.$inject_state = $$props => {
		if ('actor' in $$props) $$invalidate(2, actor = $$props.actor);
		if ('edges' in $$props) $$invalidate(0, edges = $$props.edges);
		if ('nodes' in $$props) $$invalidate(1, nodes = $$props.nodes);
		if ('digraph' in $$props) $$invalidate(5, digraph = $$props.digraph);
		if ('activeIds' in $$props) $$invalidate(3, activeIds = $$props.activeIds);
		if ('previewIds' in $$props) $$invalidate(4, previewIds = $$props.previewIds);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [edges, nodes, actor, activeIds, previewIds, digraph, flatten];
}

class Graph extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance, create_fragment, safe_not_equal, {
			actor: 2,
			edges: 0,
			nodes: 1,
			digraph: 5,
			flatten: 6
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Graph",
			options,
			id: create_fragment.name
		});
	}

	get actor() {
		throw new Error("<Graph>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set actor(value) {
		throw new Error("<Graph>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get edges() {
		throw new Error("<Graph>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set edges(value) {
		throw new Error("<Graph>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get nodes() {
		throw new Error("<Graph>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set nodes(value) {
		throw new Error("<Graph>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get digraph() {
		throw new Error("<Graph>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set digraph(value) {
		throw new Error("<Graph>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get flatten() {
		return flatten;
	}

	set flatten(value) {
		throw new Error("<Graph>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

import * as ___SVELTE_HMR_HOT_API from "/@fs/home/zavx0z/botswork/node_modules/svelte-hmr/runtime/hot-api-esm.js?v=8b273cb8";import { adapter as ___SVELTE_HMR_HOT_API_PROXY_ADAPTER } from "/@fs/home/zavx0z/botswork/node_modules/svelte-hmr/runtime/proxy-adapter-dom.js?v=8b273cb8";if (import.meta && import.meta.hot) { if (false) import.meta.hot.acceptExports(['default']);; Graph = ___SVELTE_HMR_HOT_API.applyHmr({ m: import.meta, id: "/home/zavx0z/botswork/lib/viz/src/lib/Graph.svelte", hotOptions: {"preserveLocalState":false,"noPreserveStateKey":["@hmr:reset","@!hmr"],"preserveAllLocalStateKey":"@hmr:keep-all","preserveLocalStateKey":"@hmr:keep","noReload":false,"optimistic":false,"acceptNamedExports":true,"acceptAccessors":true,"injectCss":false,"cssEjectDelay":100,"native":false,"importAdapterName":"___SVELTE_HMR_HOT_API_PROXY_ADAPTER","noOverlay":true,"allowLiveBinding":false,"partialAccept":true}, Component: Graph, ProxyAdapter: ___SVELTE_HMR_HOT_API_PROXY_ADAPTER, acceptable: true, preserveLocalState: false, emitCss: true, }); }
export default Graph;


//# sourceMappingURL=data:application/json;base64,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VUFDcEI7S0FDSixPQUFPLFVBQVUsRUFBRSxJQUFJLGVBQWUsSUFBSSxXQUFXO0tBQ3JELFFBQVEsVUFBVTtLQUNsQixRQUFRLE9BQU87S0FDZixZQUFZO0tBQ1o7S0FDQTtNQUFTLE1BQU0sRUFBRTtNQUFXLEdBQUc7TUFBRyxHQUFHO01BQUcsT0FBTztNQUFHLFFBQVE7Ozs7V0FJckQ7Ozs7UUFJUDtHQUNKLElBQUksVUFBVTtHQUNkO0dBQ0EsVUFBVSxZQUFZLFNBQXlCLEVBQUUsSUFBSSxlQUFlO0dBQ3BFLE9BQU87OztrQkFFVCxNQUFNLE1BQU0sRUFBRSxJQUFJLE1BQU07U0FFakI7OztDQUdUO1FBQ1EsVUFBVSxNQUFNLGNBQWMsUUFBUTtNQUN4QyxJQUFJLGdCQUFnQixPQUFPO1FBQ3pCO1FBR0EsYUFBYSxZQUFZLENBQUM7OztLQUs5QixZQUFZLE1BQU0sY0FBYyxRQUFRLE1BQU0sY0FBYyxJQUFLLEtBQW9CLEVBQUUsRUFBRTtLQUN6Rjs7Q0FDSjtVQUNVLGdCQUFnQixNQUFNLFVBQVc7T0FDbkMsTUFBTTtvQkFDUixhQUFhLE1BQU0sUUFBUTtNQUFlLE1BQU0sUUFBUSxRQUFRLFdBQVcsTUFBTSxRQUFRLFNBQVMsTUFBTSxNQUFNLFFBQVEsZ0JBQWdCLGNBQWMsSUFBSyxLQUFvQixFQUFFLEVBQUU7OztvQkFDakwsWUFBWSxNQUFNLFFBQVEsTUFBTSxjQUFjLElBQUssS0FBb0IsRUFBRSxFQUFFOzs7OztHQUk3RSIsIm5hbWVzIjpbImVkZ2VzIiwiZGlncmFwaCIsImVsa05vZGUiXSwic291cmNlcyI6WyJHcmFwaC5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPHNjcmlwdCBsYW5nPVwidHNcIj5cbiAgaW1wb3J0IHR5cGUgeyBFbGtFZGdlU2VjdGlvbiwgRWxrTm9kZSB9IGZyb20gXCJlbGtqc1wiXG4gIGltcG9ydCB0eXBlIHsgU3RhdGVOb2RlLCBBbnlTdGF0ZU1hY2hpbmUsIEFueVN0YXRlTm9kZSwgQW55SW50ZXJwcmV0ZXIgfSBmcm9tIFwiQGxpYi9tYWNoaW5lXCJcbiAgaW1wb3J0IHR5cGUgeyBTdGF0ZUVsa05vZGUsIFN0YXRlRWxrRWRnZSwgRGlyZWN0ZWRHcmFwaE5vZGUsIERpcmVjdGVkR3JhcGhFZGdlLCBSZWxhdGl2ZU5vZGVFZGdlTWFwIH0gZnJvbSBcIi4vdHlwZXNcIlxuXG4gIGltcG9ydCBFTEsgZnJvbSBcImVsa2pzXCJcbiAgaW1wb3J0IHsgb25Nb3VudCwgdGljayB9IGZyb20gXCJzdmVsdGVcIlxuXG4gIGltcG9ydCBTdGF0ZSBmcm9tIFwiLi9TdGF0ZS5zdmVsdGVcIlxuICBpbXBvcnQgRWRnZSBmcm9tIFwiLi9FZGdlLnN2ZWx0ZVwiXG4gIGltcG9ydCBUcmFuc2l0aW9uIGZyb20gXCIuL1RyYW5zaXRpb24uc3ZlbHRlXCJcblxuICBleHBvcnQgbGV0IGFjdG9yOiBBbnlJbnRlcnByZXRlclxuXG4gIGV4cG9ydCBsZXQgZWRnZXM6IHsgW2tleTogc3RyaW5nXTogRGlyZWN0ZWRHcmFwaEVkZ2UgfSA9IHt9XG4gIGV4cG9ydCBsZXQgbm9kZXM6IHsgW2tleTogc3RyaW5nXTogQW55U3RhdGVOb2RlIH0gPSB7fVxuICBleHBvcnQgbGV0IGRpZ3JhcGg6IERpcmVjdGVkR3JhcGhOb2RlXG5cbiAgY29uc3QgZWxrID0gbmV3IEVMSyh7IGRlZmF1bHRMYXlvdXRPcHRpb25zOiB7fSB9KVxuICAvKiogRWxrLdC+0LHRitC10LrRgiDRg9C30LvQsCBodHRwczovL2VjbGlwc2UuZGV2L2Vsay9kb2N1bWVudGF0aW9uL3Rvb2xkZXZlbG9wZXJzL2dyYXBoZGF0YXN0cnVjdHVyZS9qc29uZm9ybWF0Lmh0bWxcbiAgICogQHBhcmFtIHtEaXJlY3RlZEdyYXBoTm9kZX0gbm9kZVxuICAgKiBAcGFyYW0ge1JlbGF0aXZlTm9kZUVkZ2VNYXB9IHJNYXBcbiAgICogQHJldHVybnMge1N0YXRlRWxrTm9kZX1cbiAgICovXG4gIGZ1bmN0aW9uIGdldEVsa0NoaWxkKG5vZGU6IERpcmVjdGVkR3JhcGhOb2RlLCByTWFwOiBSZWxhdGl2ZU5vZGVFZGdlTWFwKTogU3RhdGVFbGtOb2RlIHtcbiAgICBjb25zdCBsYXlvdXQgPSBub2Rlc1tub2RlLmlkXS5tZXRhLmxheW91dCAvLyDQlNC+0YHRgtCw0LXQvCDQuNC90YTQvtGA0LzQsNGG0LjRjiDQviDRgNCw0LfQvNC10YLQutC1INGC0LXQutGD0YnQtdCz0L4g0YPQt9C70LBcbiAgICBjb25zdCBlZGdlcyA9IHJNYXBbMF0uZ2V0KG5vZGUuc3RhdGVOb2RlKSB8fCBbXSAvLyDQn9C+0LvRg9GH0LDQtdC8INC40YHRhdC+0LTRj9GJ0LjQtSDQs9GA0LDQvdC4INGC0LXQutGD0YnQtdCz0L4g0YPQt9C70LAg0LjQtyDQutCw0YDRgtGLINC+0YLQvdC+0YHQuNGC0LXQu9GM0L3Ri9GFINCz0YDQsNC90LXQuVxuICAgIHJldHVybiB7XG4gICAgICBpZDogbm9kZS5pZCxcbiAgICAgIC8vINCj0YHRgtCw0L3QsNCy0LvQuNCy0LDQtdC8INGI0LjRgNC40L3RgyDQuCDQstGL0YHQvtGC0YMg0YPQt9C70LAsINC10YHQu9C4INGDINC90LXQs9C+INC90LXRgiDQtNC10YLQtdC5XG4gICAgICAuLi4obm9kZS5jaGlsZHJlbi5sZW5ndGggPyB1bmRlZmluZWQgOiB7IHdpZHRoOiBsYXlvdXQud2lkdGgsIGhlaWdodDogbGF5b3V0LmhlaWdodCB9KSxcbiAgICAgIGNoaWxkcmVuOiBub2RlLmNoaWxkcmVuLm1hcCgoY2hpbGROb2RlKSA9PiBnZXRFbGtDaGlsZChjaGlsZE5vZGUsIHJNYXApKSxcbiAgICAgIGVkZ2VzOiBlZGdlcy5tYXAoZ2V0RWxrRWRnZSksXG4gICAgICBsYXlvdXRPcHRpb25zOiB7XG4gICAgICAgIFwiZWxrLnBhZGRpbmdcIjogYFt0b3A9JHsobGF5b3V0LmhlaWdodCB8fCAwKSArIDMwfSwgbGVmdD0zMCwgcmlnaHQ9MzAsIGJvdHRvbT0zMF1gLCAvLyDQlNC+0LHQsNCy0LvRj9C10Lwg0L7RgtGB0YLRg9C/0Ysg0LLQvtC60YDRg9CzINGD0LfQu9CwXG4gICAgICAgIGhpZXJhcmNoeUhhbmRsaW5nOiBcIklOQ0xVREVfQ0hJTERSRU5cIiwgLy8g0JLQutC70Y7Rh9Cw0LXQvCDQtNC+0YfQtdGA0L3QuNC1INGD0LfQu9GLINCyINC40LXRgNCw0YDRhdC40Y5cbiAgICAgIH0sXG4gICAgICBub2RlLCAvLyDQodC+0YXRgNCw0L3Rj9C10Lwg0YHRgdGL0LvQutGDINC90LAg0LjRgdGF0L7QtNC90YvQuSDRg9C30LXQu1xuICAgICAgLy8gYWJzb2x1dGVQb3NpdGlvbjogeyB4OiAwLCB5OiAwIH0sINCX0LDQtNCw0LXQvCDQvdCw0YfQsNC70YzQvdGD0Y4g0LDQsdGB0L7Qu9GO0YLQvdGD0Y4g0L/QvtC30LjRhtC40Y4g0YPQt9C70LAgKNC+0YLQvdC+0YHQuNGC0LXQu9GM0L3QviDRgNC+0LTQuNGC0LXQu9GPKVxuICAgIH1cbiAgfVxuICAvKiogRWxrLdC+0LHRitC10LrRgiDQs9GA0LDQvdC4XG4gICAqIEBwYXJhbSB7RGlyZWN0ZWRHcmFwaEVkZ2V9IGVkZ2VcbiAgICovXG4gIGNvbnN0IGdldEVsa0VkZ2UgPSAoZWRnZTogRGlyZWN0ZWRHcmFwaEVkZ2UpID0+ICh7XG4gICAgaWQ6IGVkZ2UuaWQsXG4gICAgLy8g0KPRgdGC0LDQvdCw0LLQu9C40LLQsNC10Lwg0LjRgdGC0L7Rh9C90LjQuiDQuCDRhtC10LvRjCDQtNGD0LPQuFxuICAgIHNvdXJjZXM6IFtlZGdlLnNvdXJjZV0sXG4gICAgdGFyZ2V0czogW2VkZ2UudGFyZ2V0XSxcbiAgICAvLyDQlNC+0LHQsNCy0LvRj9C10Lwg0LzQtdGC0LrRgyDQvdCwINC00YPQs9GDINGBINC/0LDRgNCw0LzQtdGC0YDQsNC80Lgg0YDQsNC30LzQtdGC0LrQuFxuICAgIGxhYmVsczogW1xuICAgICAge1xuICAgICAgICBpZDogZWRnZS5pZCArIFwiLS1sYWJlbFwiLCAvLyDQo9C90LjQutCw0LvRjNC90YvQuSBJRCDQvNC10YLQutC4XG4gICAgICAgIHdpZHRoOiBlZGdlc1tlZGdlLmlkXS5sYWJlbC53aWR0aCwgLy8g0KjQuNGA0LjQvdCwINC80LXRgtC60LhcbiAgICAgICAgaGVpZ2h0OiBlZGdlc1tlZGdlLmlkXS5sYWJlbC5oZWlnaHQsIC8vINCS0YvRgdC+0YLQsCDQvNC10YLQutC4XG4gICAgICAgIHRleHQ6IGVkZ2UubGFiZWwudGV4dCB8fCBcImFsd2F5c1wiLCAvLyDQotC10LrRgdGCINC80LXRgtC60LhcbiAgICAgICAgbGF5b3V0T3B0aW9uczoge1xuICAgICAgICAgIFwiZWRnZUxhYmVscy5pbmxpbmVcIjogXCJ0cnVlXCIsIC8vINCy0YHRgtGA0L7QtdC90L3QsNGPINC80LXRgtC60LBcbiAgICAgICAgICBcImVkZ2VMYWJlbHMucGxhY2VtZW50XCI6IFwiQ0VOVEVSXCIsIC8vINGA0LDRgdC/0L7Qu9C+0LbQtdC90LjQtSDQv9C+INGG0LXQvdGC0YDRg1xuICAgICAgICB9LFxuICAgICAgfSxcbiAgICBdLFxuICAgIGVkZ2UsIC8vINCh0L7RhdGA0LDQvdGP0LXQvCDRgdGB0YvQu9C60YMg0L3QsCDQuNGB0YXQvtC00L3Rg9GOINC00YPQs9GDXG4gICAgc2VjdGlvbnM6IFtdLCAvLyDQn9C+0LrQsCDQvdC1INC30LDQtNCw0LXQvCDRgdC10LrRhtC40Lgg0LTRg9Cz0LggKNC80L7Qs9GD0YIg0LHRi9GC0Ywg0LTQvtCx0LDQstC70LXQvdGLINC/0L7Qt9C20LUpXG4gIH0pXG5cbiAgZnVuY3Rpb24gZ2V0UmVsYXRpdmVOb2RlRWRnZU1hcCgpOiBSZWxhdGl2ZU5vZGVFZGdlTWFwIHtcbiAgICAvLyDQodC+0LfQtNCw0LXQvCDQtNCy0LUg0L/Rg9GB0YLRi9C1INC60LDRgNGC0Ys6INC60LDRgNGC0YMg0YPQt9C70L7QsiDQuCDQutCw0YDRgtGDINC00YPQs1xuICAgIGNvbnN0IG1hcDogUmVsYXRpdmVOb2RlRWRnZU1hcFswXSA9IG5ldyBNYXAoKVxuICAgIGNvbnN0IGVkZ2VNYXA6IFJlbGF0aXZlTm9kZUVkZ2VNYXBbMV0gPSBuZXcgTWFwKClcbiAgICAvLyDQpNGD0L3QutGG0LjRjyDQtNC70Y8g0L/QvtC40YHQutCwINC90LDQuNC80LXQvdGM0YjQtdCz0L4g0L7QsdGJ0LXQs9C+INC/0YDQtdC00LrQsCAo0J3QodCfKSDQtNCy0YPRhSDRg9C30LvQvtCyXG4gICAgY29uc3QgZ2V0TENBID0gKHNvdXJjZTogU3RhdGVOb2RlLCB0YXJnZXQ6IFN0YXRlTm9kZSk6IFN0YXRlTm9kZSB8IHVuZGVmaW5lZCA9PiB7XG4gICAgICAvLyAxLiDQodCw0LzQvi3Qv9C10YDQtdGF0L7QtC4g0JXRgdC70Lgg0YPQt9C70Ysg0YHQvtCy0L/QsNC00LDRjtGCLCDQstC+0LfQstGA0LDRidCw0LXQvCDQuNGFINGA0L7QtNC40YLQtdC70Y9cbiAgICAgIGlmIChzb3VyY2UgPT09IHRhcmdldCkgcmV0dXJuIHNvdXJjZS5wYXJlbnQgXG4gICAgICAvLyAyLiDQntCx0YnQuNC5INC/0YDQtdC00L7QulxuICAgICAgLy8g0KHQsdC+0YAg0LLRgdC10YUg0L/RgNC10LTQutC+0LIg0YPQt9C70LAg0LjRgdGC0L7Rh9C90LjQutCwXG4gICAgICBjb25zdCBzZXQgPSBuZXcgU2V0KCkgXG4gICAgICBsZXQgbm9kZSA9IHNvdXJjZS5wYXJlbnQgXG4gICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICBzZXQuYWRkKG5vZGUpIFxuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnRcbiAgICAgIH1cbiAgICAgIC8vINCf0L7QuNGB0Log0LHQu9C40LbQsNC50YjQtdCz0L4g0L7QsdGJ0LXQs9C+INC/0YDQtdC00LrQsFxuICAgICAgbm9kZSA9IHRhcmdldCBcbiAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgIGlmIChzZXQuaGFzKG5vZGUpKSByZXR1cm4gbm9kZSAvLyDQldGB0LvQuCDQv9GA0LXQtNC+0Log0LLRgtC+0YDQvtCz0L4g0YPQt9C70LAg0L3QsNC50LTQtdC9INCyINC80L3QvtC20LXRgdGC0LLQtSwg0LLQvtC30LLRgNCw0YnQsNC10Lwg0LXQs9C+XG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudCAvLyDQn9C10YDQtdGF0L7QtNC40Lwg0Log0YHQu9C10LTRg9GO0YnQtdC80YMg0L/RgNC10LTQutGDINGD0LfQu9CwINC90LDQt9C90LDRh9C10L3QuNGPXG4gICAgICB9XG4gICAgICAvLyAzLiDQldGB0LvQuCDQndCh0J8g0L3QtSDQvdCw0LnQtNC10L0sINCy0L7Qt9Cy0YDQsNGJ0LDQtdC8INC80LDRiNC40L3RgyDQv9C10YDQstC+0LPQviDRg9C30LvQsFxuICAgICAgcmV0dXJuIHNvdXJjZS5tYWNoaW5lIFxuICAgIH1cbiAgICAvLyDQn9GA0L7RhdC+0LTQuNC80YHRjyDQv9C+INCy0YHQtdC8INC00YPQs9Cw0Lwg0Lgg0LfQsNC/0LjRgdGL0LLQsNC10Lwg0LjRhSDQsiDQutCw0YDRgtGLXG4gICAgT2JqZWN0LnZhbHVlcyhlZGdlcykuZm9yRWFjaCgoZWRnZSkgPT4ge1xuICAgICAgY29uc3QgbGNhID0gZ2V0TENBKG5vZGVzW2VkZ2Uuc291cmNlXSwgbm9kZXNbZWRnZS50YXJnZXRdKSAvLyDQndCw0YXQvtC00LjQvCDQsdC70LjQttCw0LnRiNC10LPQviDQvtCx0YnQtdCz0L4g0L/RgNC10LTQutCwINGD0LfQu9C+0LIg0LjRgdGC0L7Rh9C90LjQutCwINC/0LXRgNC10YXQvtC00LBcbiAgICAgIGlmICghbWFwLmhhcyhsY2EpKSBtYXAuc2V0KGxjYSwgW10pIC8vINCV0YHQu9C4INC+0LHRidC10LPQviDQv9GA0LXQtNC60LAg0L3QtdGCINCyINC60LDRgNGC0LUsINC00L7QsdCw0LLQu9GP0LXQvCDQsiDQstC40LTQtSDQutC70Y7Rh9CwINC90L7QtNGDINC4INCyINCy0LjQtNC1INC30L3QsNGH0LXQvdC40Y8g0L/Rg9GB0YLQvtC5INC80LDRgdGB0LjQslxuICAgICAgbWFwLmdldChsY2EpIS5wdXNoKGVkZ2UpIC8vINCU0L7QsdCw0LLQu9GP0LXQvCDQv9C10YDQtdGF0L7QtCDQsiDRgdC/0LjRgdC+0Log0L3QvtC00Ysg0L/RgNC10LTQutCwXG4gICAgICBlZGdlTWFwLnNldChlZGdlLmlkLCBsY2EpIC8vINCX0LDQv9C40YHRi9Cy0LDQtdC8INGB0LLRj9C30Ywg0LzQtdC20LTRgyDQuNC00LXQvdGC0LjRhNC40LrQsNGC0L7RgNC+0Lwg0L/QtdGA0LXRhdC+0LTQsCDQuCDQv9GA0LXQtNC60LBcbiAgICB9KVxuXG4gICAgLy8g0JLQvtC30LLRgNCw0YnQsNC10Lwg0L7QsdC1INC60LDRgNGC0YtcbiAgICByZXR1cm4gW21hcCwgZWRnZU1hcF1cbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIGdldEVsa0dyYXBoKGRpZ3JhcGg6IERpcmVjdGVkR3JhcGhOb2RlKTogUHJvbWlzZTxFbGtOb2RlPiB7XG4gICAgY29uc3Qgck1hcCA9IGdldFJlbGF0aXZlTm9kZUVkZ2VNYXAoKVxuICAgIGNvbnN0IHJvb3RFZGdlcyA9IHJNYXBbMF0uZ2V0KHVuZGVmaW5lZCkgfHwgW11cbiAgICBjb25zdCBlbGtOb2RlOiBFbGtOb2RlID0ge1xuICAgICAgaWQ6IFwicm9vdFwiLFxuICAgICAgZWRnZXM6IHJvb3RFZGdlcy5tYXAoZ2V0RWxrRWRnZSksXG4gICAgICBjaGlsZHJlbjogW2dldEVsa0NoaWxkKGRpZ3JhcGgsIHJNYXApXSxcbiAgICAgIGxheW91dE9wdGlvbnM6IHtcbiAgICAgICAgXCJlbGsuaGllcmFyY2h5SGFuZGxpbmdcIjogXCJJTkNMVURFX0NISUxEUkVOXCIsXG4gICAgICAgIFwiZWxrLmFsZ29yaXRobVwiOiBcImxheWVyZWRcIixcbiAgICAgICAgXCJlbGsubGF5ZXJlZC5jcm9zc2luZ01pbmltaXphdGlvbi5zZW1pSW50ZXJhY3RpdmVcIjogXCJ0cnVlXCIsXG4gICAgICB9LFxuICAgIH1cbiAgICBjb25zdCBsYXlvdXRFbGtOb2RlID0gYXdhaXQgZWxrLmxheW91dChlbGtOb2RlKVxuICAgIGNvbnN0IHN0YXRlTm9kZVRvRWxrTm9kZU1hcCA9IG5ldyBNYXA8U3RhdGVOb2RlLCBTdGF0ZUVsa05vZGU+KClcblxuICAgIGNvbnN0IHNldEVkZ2VMYXlvdXQgPSAoZWRnZTogU3RhdGVFbGtFZGdlKSA9PiB7XG4gICAgICBjb25zdCBsY2EgPSByTWFwWzFdLmdldChlZGdlLmlkKVxuXG4gICAgICBjb25zdCBlbGtMY2EgPSBsY2EgJiYgc3RhdGVOb2RlVG9FbGtOb2RlTWFwLmdldChsY2EpIVxuICAgICAgZWRnZXNbZWRnZS5pZF0ubGFiZWwueCA9IGVsa0xjYT8ueCB8fCAwXG4gICAgICBlZGdlc1tlZGdlLmlkXS5sYWJlbC55ID0gZWxrTGNhPy55IHx8IDBcblxuICAgICAgaWYgKGVkZ2Uuc2VjdGlvbnMpIHtcbiAgICAgICAgY29uc3QgdHJhbnNsYXRlZFNlY3Rpb25zOiBFbGtFZGdlU2VjdGlvbltdIHwgdW5kZWZpbmVkID0gZWxrTGNhXG4gICAgICAgICAgPyBlZGdlLnNlY3Rpb25zLm1hcCgoc2VjdGlvbikgPT4gKHtcbiAgICAgICAgICAgICAgLi4uc2VjdGlvbixcbiAgICAgICAgICAgICAgc3RhcnRQb2ludDoge1xuICAgICAgICAgICAgICAgIHg6IHNlY3Rpb24uc3RhcnRQb2ludC54ICsgZWxrTGNhLmFic29sdXRlUG9zaXRpb24ueCxcbiAgICAgICAgICAgICAgICB5OiBzZWN0aW9uLnN0YXJ0UG9pbnQueSArIGVsa0xjYS5hYnNvbHV0ZVBvc2l0aW9uLnksXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGVuZFBvaW50OiB7XG4gICAgICAgICAgICAgICAgeDogc2VjdGlvbi5lbmRQb2ludC54ICsgZWxrTGNhLmFic29sdXRlUG9zaXRpb24ueCxcbiAgICAgICAgICAgICAgICB5OiBzZWN0aW9uLmVuZFBvaW50LnkgKyBlbGtMY2EuYWJzb2x1dGVQb3NpdGlvbi55LFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBiZW5kUG9pbnRzOiBzZWN0aW9uLmJlbmRQb2ludHM/Lm1hcCgoYmVuZFBvaW50KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgIHg6IGJlbmRQb2ludC54ICsgZWxrTGNhLmFic29sdXRlUG9zaXRpb24ueCxcbiAgICAgICAgICAgICAgICAgIHk6IGJlbmRQb2ludC55ICsgZWxrTGNhLmFic29sdXRlUG9zaXRpb24ueSxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfSkpXG4gICAgICAgICAgOiBlZGdlLnNlY3Rpb25zXG4gICAgICAgIGlmICh0cmFuc2xhdGVkU2VjdGlvbnMpIGVkZ2UuZWRnZS5zZWN0aW9ucyA9IHRyYW5zbGF0ZWRTZWN0aW9uc1xuICAgICAgfVxuXG4gICAgICBlZGdlLmVkZ2UubGFiZWwueCA9IChlZGdlLmxhYmVscz8uWzBdLnggfHwgMCkgKyAoZWxrTGNhPy5hYnNvbHV0ZVBvc2l0aW9uLnggfHwgMClcbiAgICAgIGVkZ2UuZWRnZS5sYWJlbC55ID0gKGVkZ2UubGFiZWxzPy5bMF0ueSB8fCAwKSArIChlbGtMY2E/LmFic29sdXRlUG9zaXRpb24ueSB8fCAwKVxuICAgIH1cbiAgICBjb25zdCBzZXRMYXlvdXQgPSAoZWxrTm9kZTogU3RhdGVFbGtOb2RlLCBwYXJlbnQ6IFN0YXRlRWxrTm9kZSB8IHVuZGVmaW5lZCkgPT4ge1xuICAgICAgc3RhdGVOb2RlVG9FbGtOb2RlTWFwLnNldChlbGtOb2RlLm5vZGUuc3RhdGVOb2RlLCBlbGtOb2RlKVxuICAgICAgZWxrTm9kZS5hYnNvbHV0ZVBvc2l0aW9uID0ge1xuICAgICAgICB4OiAocGFyZW50Py5hYnNvbHV0ZVBvc2l0aW9uLnggPz8gMCkgKyBlbGtOb2RlLnghLFxuICAgICAgICB5OiAocGFyZW50Py5hYnNvbHV0ZVBvc2l0aW9uLnkgPz8gMCkgKyBlbGtOb2RlLnkhLFxuICAgICAgfVxuICAgICAgZWxrTm9kZS5ub2RlLnN0YXRlTm9kZS5tZXRhID0ge1xuICAgICAgICBsYXlvdXQ6IHtcbiAgICAgICAgICB3aWR0aDogZWxrTm9kZS53aWR0aCEsXG4gICAgICAgICAgaGVpZ2h0OiBlbGtOb2RlLmhlaWdodCEsXG4gICAgICAgICAgeDogZWxrTm9kZS54ISxcbiAgICAgICAgICB5OiBlbGtOb2RlLnkhLFxuICAgICAgICB9LFxuICAgICAgfVxuICAgICAgbm9kZXNbZWxrTm9kZS5pZF0ubWV0YSA9IHtcbiAgICAgICAgbGF5b3V0OiB7XG4gICAgICAgICAgd2lkdGg6IGVsa05vZGUud2lkdGghLFxuICAgICAgICAgIGhlaWdodDogZWxrTm9kZS5oZWlnaHQhLFxuICAgICAgICAgIHg6IChwYXJlbnQ/LmFic29sdXRlUG9zaXRpb24ueCA/PyAwKSArIGVsa05vZGUueCEsXG4gICAgICAgICAgeTogKHBhcmVudD8uYWJzb2x1dGVQb3NpdGlvbi55ID8/IDApICsgZWxrTm9kZS55ISxcbiAgICAgICAgfSxcbiAgICAgIH1cbiAgICAgIGVsa05vZGUuZWRnZXM/LmZvckVhY2goKGVkZ2UpID0+IHtcbiAgICAgICAgc2V0RWRnZUxheW91dChlZGdlKVxuICAgICAgfSlcbiAgICAgIGVsa05vZGUuY2hpbGRyZW4/LmZvckVhY2goKGNuKSA9PiB7XG4gICAgICAgIHNldExheW91dChjbiBhcyBTdGF0ZUVsa05vZGUsIGVsa05vZGUpXG4gICAgICB9KVxuICAgIH1cbiAgICA7KGxheW91dEVsa05vZGUuZWRnZXMgYXMgU3RhdGVFbGtFZGdlW10pPy5mb3JFYWNoKHNldEVkZ2VMYXlvdXQpXG4gICAgc2V0TGF5b3V0KGxheW91dEVsa05vZGUuY2hpbGRyZW4hWzBdIGFzIFN0YXRlRWxrTm9kZSwgdW5kZWZpbmVkKVxuICAgIHJldHVybiBsYXlvdXRFbGtOb2RlLmNoaWxkcmVuIVswXVxuICB9XG5cbiAgZXhwb3J0IGZ1bmN0aW9uIGZsYXR0ZW48VD4oYXJyYXk6IEFycmF5PFQgfCBUW10+KTogVFtdIHtcbiAgICByZXR1cm4gKFtdIGFzIFRbXSkuY29uY2F0KC4uLmFycmF5KVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Q2hpbGRyZW4oc3RhdGVOb2RlOiBTdGF0ZU5vZGUpOiBTdGF0ZU5vZGVbXSB7XG4gICAgaWYgKCFzdGF0ZU5vZGUuc3RhdGVzKSByZXR1cm4gW11cbiAgICBjb25zdCBjaGlsZHJlbiA9IE9iamVjdC5rZXlzKHN0YXRlTm9kZS5zdGF0ZXMpLm1hcCgoa2V5KSA9PiBzdGF0ZU5vZGUuc3RhdGVzW2tleV0pXG4gICAgY2hpbGRyZW4uc29ydCgoYSwgYikgPT4gYi5vcmRlciAtIGEub3JkZXIpXG4gICAgcmV0dXJuIGNoaWxkcmVuXG4gIH1cblxuICBmdW5jdGlvbiB0b0RpcmVjdGVkR3JhcGgoc3RhdGVOb2RlOiBBbnlTdGF0ZU5vZGUgfCBBbnlTdGF0ZU1hY2hpbmUpOiBEaXJlY3RlZEdyYXBoTm9kZSB7XG4gICAgY29uc3QgZWdzOiBEaXJlY3RlZEdyYXBoRWRnZVtdID0gZmxhdHRlbihcbiAgICAgIHN0YXRlTm9kZS50cmFuc2l0aW9ucy5tYXAoKHQsIHRyYW5zaXRpb25JbmRleCkgPT4ge1xuICAgICAgICBjb25zdCB0YXJnZXRzID0gdC50YXJnZXQgPyB0LnRhcmdldCA6IFtzdGF0ZU5vZGVdXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKHQsIHRhcmdldHMpXG4gICAgICAgIHJldHVybiB0YXJnZXRzLm1hcCgodGFyZ2V0LCB0YXJnZXRJbmRleCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGVkZ2U6IERpcmVjdGVkR3JhcGhFZGdlID0ge1xuICAgICAgICAgICAgaWQ6IGAke3N0YXRlTm9kZS5pZH06JHt0cmFuc2l0aW9uSW5kZXh9OiR7dGFyZ2V0SW5kZXh9YCxcbiAgICAgICAgICAgIHNvdXJjZTogc3RhdGVOb2RlLmlkLFxuICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXQuaWQsXG4gICAgICAgICAgICB0cmFuc2l0aW9uOiB0LFxuICAgICAgICAgICAgc2VjdGlvbnM6IFtdLFxuICAgICAgICAgICAgbGFiZWw6IHsgdGV4dDogdC5ldmVudFR5cGUsIHg6IDAsIHk6IDAsIHdpZHRoOiAwLCBoZWlnaHQ6IDAgfSxcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gZWRnZXNbZWRnZS5pZF0gPSBlZGdlXG4gICAgICAgICAgLy8gY29uc29sZS5sb2coZWRnZSlcbiAgICAgICAgICByZXR1cm4gZWRnZVxuICAgICAgICB9KVxuICAgICAgfSksXG4gICAgKVxuICAgIGNvbnN0IGdyYXBoOiBEaXJlY3RlZEdyYXBoTm9kZSA9IHtcbiAgICAgIGlkOiBzdGF0ZU5vZGUuaWQsXG4gICAgICBzdGF0ZU5vZGU6IHN0YXRlTm9kZSBhcyBBbnlTdGF0ZU5vZGUsXG4gICAgICBjaGlsZHJlbjogZ2V0Q2hpbGRyZW4oc3RhdGVOb2RlIGFzIEFueVN0YXRlTm9kZSkubWFwKHRvRGlyZWN0ZWRHcmFwaCksXG4gICAgICBlZGdlczogZWdzLFxuICAgIH1cbiAgICBub2Rlc1tncmFwaC5pZF0gPSBncmFwaC5zdGF0ZU5vZGVcbiAgICAvLyBjb25zb2xlLmxvZyhncmFwaC5zdGF0ZU5vZGUpXG4gICAgcmV0dXJuIGdyYXBoXG4gIH1cblxuICBvbk1vdW50KGFzeW5jICgpID0+IHtcbiAgICBjb25zdCBtYWNoaW5lID0gYWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0Lm1hY2hpbmVcbiAgICBsZXQgZCA9IHRvRGlyZWN0ZWRHcmFwaChtYWNoaW5lKVxuICAgIGF3YWl0IHRpY2soKVxuICAgIC8vIGNvbnNvbGUubG9nKGRpZ3JhcGgpXG4gICAgLy8gY29uc29sZS5sb2cobm9kZXMpXG4gICAgY29uc3QgZWxrZyA9IGF3YWl0IGdldEVsa0dyYXBoKGQpXG4gICAgLy8gY29uc3QgZWxrZyA9IGF3YWl0IGdldEVsa0dyYXBoKGRpZ3JhcGgpXG4gICAgLy8gY29uc29sZS5sb2coZWxrZylcbiAgfSlcblxuICBsZXQgYWN0aXZlSWRzID0gYWN0b3IuZ2V0U25hcHNob3QoKS5jb250ZXh0LnN0YXRlLmNvbmZpZ3VyYXRpb24ubWFwKChpOiBBbnlTdGF0ZU5vZGUpID0+IGkuaWQpXG4gIGxldCBwcmV2aWV3SWRzOiBzdHJpbmdbXSA9IFtdXG4gIG9uTW91bnQoKCkgPT4ge1xuICAgIGNvbnN0IHsgdW5zdWJzY3JpYmUgfSA9IGFjdG9yLnN1YnNjcmliZSgoc3RhdGUpID0+IHtcbiAgICAgIGlmIChzdGF0ZS5jaGFuZ2VkKSB7XG4gICAgICAgIHByZXZpZXdJZHMgPSBzdGF0ZS5jb250ZXh0LnByZXZpZXdFdmVudCA/IHN0YXRlLmNvbnRleHQubWFjaGluZS50cmFuc2l0aW9uKHN0YXRlLmNvbnRleHQuc3RhdGUsIHsgdHlwZTogc3RhdGUuY29udGV4dC5wcmV2aWV3RXZlbnQgfSkuY29uZmlndXJhdGlvbi5tYXAoKGk6IEFueVN0YXRlTm9kZSkgPT4gaS5pZCkgOiBbXVxuICAgICAgICBhY3RpdmVJZHMgPSBzdGF0ZS5jb250ZXh0LnN0YXRlLmNvbmZpZ3VyYXRpb24ubWFwKChpOiBBbnlTdGF0ZU5vZGUpID0+IGkuaWQpXG4gICAgICB9XG4gICAgfSlcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgdW5zdWJzY3JpYmUoKVxuICAgIH1cbiAgfSlcbjwvc2NyaXB0PlxuXG57I2VhY2ggT2JqZWN0LmVudHJpZXMobm9kZXMpIGFzIFtpZCwgbm9kZV0gKGlkKX1cbiAgPFN0YXRlIHtub2RlfSB7cHJldmlld0lkc30ge2FjdGl2ZUlkc30gLz5cbnsvZWFjaH1cbjxzdmcgY2xhc3M9XCJwb2ludGVyLWV2ZW50cy1ub25lIGZpeGVkIGxlZnQtMCB0b3AtMCBoLXNjcmVlbiB3LXNjcmVlbiBvdmVyZmxvdy12aXNpYmxlXCI+XG4gIHsjZWFjaCBPYmplY3QuZW50cmllcyhlZGdlcykgYXMgW2lkLCBlZGdlXSwgb3JkZXIgKGlkKX1cbiAgICA8RWRnZSB7ZWRnZX0ge25vZGVzfSB7YWN0aXZlSWRzfSB7b3JkZXJ9IC8+XG4gIHsvZWFjaH1cbjwvc3ZnPlxueyNlYWNoIE9iamVjdC5lbnRyaWVzKGVkZ2VzKSBhcyBbaWQsIGVkZ2VdIChpZCl9XG4gIDxUcmFuc2l0aW9uIHtlZGdlfSB7YWN0aXZlSWRzfSB7YWN0b3J9IC8+XG57L2VhY2h9XG4iXX0=